#!/usr/bin/env bash
# warp-multi - Multiple egresses for X-UI / Xray load-balancing
# Works by creating N network namespaces, each with its own egress and a SOCKS5 proxy.
# Modes:
#   - warp: Cloudflare WARP via WireGuard (wgcf) inside each netns
#   - snat: Egress via server public IPv4s (SNAT per netns subnet)
#
# Ubuntu/Debian (systemd) only.
#
# License: MIT
set -euo pipefail

VERSION="0.2.4"

CONFIG_FILE="/etc/warp-multi.conf"
WG_DIR="/etc/wireguard"
STATE_DIR="/etc/warp-multi"

SYSCTL_FILE="/etc/sysctl.d/99-warp-multi.conf"
UNIT_NETNS="/etc/systemd/system/warp-netns@.service"
UNIT_SOCKS="/etc/systemd/system/warp-socks@.service"

# Defaults (can be set via install flags or by editing CONFIG_FILE)
COUNT_DEFAULT=10
BASE_PORT_DEFAULT=40000
BASE_NET_DEFAULT="10.250" # uses ${BASE_NET}.${i}.0/24
NS_PREFIX_DEFAULT="warp"
WG_PREFIX_DEFAULT="warp"
MODE_DEFAULT="warp" # warp|snat
EGRESS_IPS_DEFAULT="" # for MODE=snat: comma-separated public IPv4 list (e.g. 1.2.3.4,5.6.7.8)

WGCF_VERSION_DEFAULT="2.2.22"
GOST_VERSION_DEFAULT="2.11.5"

# wgcf register rate-limit handling (Cloudflare may return 429 if you create many accounts fast)
REGISTER_DELAY_DEFAULT=8          # seconds to wait between successful registrations
REGISTER_RETRIES_DEFAULT=8        # retries when 429 happens
REGISTER_BACKOFF_BASE_DEFAULT=15  # exponential backoff base seconds (15,30,60,120,...)
REGISTER_BACKOFF_MAX_DEFAULT=900  # max backoff seconds

# exit IP probing (warp-multi ips/status)
EXIT_IP_RETRIES_DEFAULT=3
EXIT_IP_DELAY_DEFAULT=1
EXIT_IP_MAX_TIME_DEFAULT=6
EXIT_IP_URL_DEFAULT="https://cloudflare.com/cdn-cgi/trace"

log() { echo "[$(date +'%F %T')] $*"; }
warn() { echo "WARN: $*" >&2; }
die() { echo "ERROR: $*" >&2; exit 1; }

require_root() {
  [[ "${EUID:-$(id -u)}" -eq 0 ]] || die "Run as root (login as root, or use sudo if it exists)."
}

has_cmd() { command -v "$1" >/dev/null 2>&1; }

is_ipv4() {
  local ip="${1:-}"
  [[ "$ip" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]] || return 1
  local o1 o2 o3 o4
  IFS='.' read -r o1 o2 o3 o4 <<<"$ip"
  for o in "$o1" "$o2" "$o3" "$o4"; do
    [[ "$o" -ge 0 && "$o" -le 255 ]] || return 1
  done
  return 0
}

is_public_ipv4() {
  local ip="${1:-}"
  is_ipv4 "$ip" || return 1

  local o1 o2 o3 o4
  IFS='.' read -r o1 o2 o3 o4 <<<"$ip"

  # RFC1918
  if [[ "$o1" -eq 10 ]]; then return 1; fi
  if [[ "$o1" -eq 172 && "$o2" -ge 16 && "$o2" -le 31 ]]; then return 1; fi
  if [[ "$o1" -eq 192 && "$o2" -eq 168 ]]; then return 1; fi

  # Loopback / link-local / CGNAT / multicast+reserved
  if [[ "$o1" -eq 127 ]]; then return 1; fi
  if [[ "$o1" -eq 169 && "$o2" -eq 254 ]]; then return 1; fi
  if [[ "$o1" -eq 100 && "$o2" -ge 64 && "$o2" -le 127 ]]; then return 1; fi
  if [[ "$o1" -eq 0 || "$o1" -ge 224 ]]; then return 1; fi

  return 0
}

normalize_base_net() {
  # Accept A.B, A.B.C, A.B.C.D, and CIDR forms; return A.B or empty.
  local v="${1:-}"
  v="${v//[[:space:]]/}"
  v="${v%%/*}"
  if [[ "$v" =~ ^([0-9]{1,3})\.([0-9]{1,3})(\.[0-9]{1,3}){0,2}$ ]]; then
    echo "${BASH_REMATCH[1]}.${BASH_REMATCH[2]}"
    return 0
  fi
  echo ""
  return 0
}

detect_egress_ips_csv() {
  local dev="${1:?}"
  local -a ips=()
  local ip

  while IFS= read -r ip; do
    [[ -n "$ip" ]] || continue
    is_public_ipv4 "$ip" || continue
    ips+=("$ip")
  done < <(ip -o -4 addr show dev "$dev" scope global 2>/dev/null | awk '{print $4}' | cut -d/ -f1)

  if [[ "${#ips[@]}" -eq 0 ]]; then
    echo ""
    return 0
  fi

  printf '%s\n' "${ips[@]}" \
    | awk '!seen[$0]++' \
    | sort -t. -k1,1n -k2,2n -k3,3n -k4,4n \
    | paste -sd, -
}

egress_ips_count() {
  local ips="${EGRESS_IPS:-}"
  [[ -n "$ips" ]] || { echo 0; return 0; }
  local -a arr
  IFS=',' read -r -a arr <<<"$ips"
  echo "${#arr[@]}"
}

egress_ip_for_index() {
  local i="${1:?}"
  local ips="${EGRESS_IPS:-}"
  [[ -n "$ips" ]] || { echo ""; return 0; }
  local -a arr
  IFS=',' read -r -a arr <<<"$ips"
  local idx=$((i - 1))
  if [[ "$idx" -lt 0 || "$idx" -ge "${#arr[@]}" ]]; then
    echo ""
    return 0
  fi
  echo "${arr[$idx]}"
}

ensure_defaults() {
  COUNT="${COUNT:-$COUNT_DEFAULT}"
  BASE_PORT="${BASE_PORT:-$BASE_PORT_DEFAULT}"
  BASE_NET="${BASE_NET:-$BASE_NET_DEFAULT}"
  NS_PREFIX="${NS_PREFIX:-$NS_PREFIX_DEFAULT}"
  WG_PREFIX="${WG_PREFIX:-$WG_PREFIX_DEFAULT}"
  MODE="${MODE:-$MODE_DEFAULT}"
  EGRESS_IPS="${EGRESS_IPS:-$EGRESS_IPS_DEFAULT}"
  COUNT="${COUNT//[[:space:]]/}"
  BASE_PORT="${BASE_PORT//[[:space:]]/}"
  BASE_NET="${BASE_NET//[[:space:]]/}"
  NS_PREFIX="${NS_PREFIX//[[:space:]]/}"
  WG_PREFIX="${WG_PREFIX//[[:space:]]/}"
  MODE="${MODE//[[:space:]]/}"
  EGRESS_IPS="${EGRESS_IPS//[[:space:]]/}"
  UPLINK_IF="${UPLINK_IF:-}"
  UPLINK_IF="${UPLINK_IF//[[:space:]]/}"

  WGCF_VERSION="${WGCF_VERSION:-$WGCF_VERSION_DEFAULT}"
  GOST_VERSION="${GOST_VERSION:-$GOST_VERSION_DEFAULT}"

  REGISTER_DELAY="${REGISTER_DELAY:-$REGISTER_DELAY_DEFAULT}"
  REGISTER_RETRIES="${REGISTER_RETRIES:-$REGISTER_RETRIES_DEFAULT}"
  REGISTER_BACKOFF_BASE="${REGISTER_BACKOFF_BASE:-$REGISTER_BACKOFF_BASE_DEFAULT}"
  REGISTER_BACKOFF_MAX="${REGISTER_BACKOFF_MAX:-$REGISTER_BACKOFF_MAX_DEFAULT}"
}

load_config() {
  if [[ -f "$CONFIG_FILE" ]]; then
    # shellcheck disable=SC1090
    source "$CONFIG_FILE"
  fi
  ensure_defaults
}

save_config() {
  cat >"$CONFIG_FILE" <<EOFCONF
# generated by warp-multi on $(date -Iseconds)
COUNT=${COUNT}
BASE_PORT=${BASE_PORT}
BASE_NET=${BASE_NET}
NS_PREFIX=${NS_PREFIX}
WG_PREFIX=${WG_PREFIX}
MODE=${MODE}
EGRESS_IPS=${EGRESS_IPS}
UPLINK_IF=${UPLINK_IF}
WGCF_VERSION=${WGCF_VERSION}
GOST_VERSION=${GOST_VERSION}
REGISTER_DELAY=${REGISTER_DELAY}
REGISTER_RETRIES=${REGISTER_RETRIES}
REGISTER_BACKOFF_BASE=${REGISTER_BACKOFF_BASE}
REGISTER_BACKOFF_MAX=${REGISTER_BACKOFF_MAX}
EOFCONF
}

detect_uplink() {
  local dev=""

  # 1) IPv4 default route
  dev="$(ip -4 route show default 2>/dev/null | awk '{for (i=1;i<=NF;i++) if ($i=="dev") {print $(i+1); exit}}' || true)"
  if [[ -n "${dev:-}" ]]; then
    echo "$dev"
    return 0
  fi

  # 2) Route lookup to a well-known IPv4
  dev="$(ip route get 1.1.1.1 2>/dev/null | awk '{for (i=1;i<=NF;i++) if ($i=="dev") {print $(i+1); exit}}' || true)"
  if [[ -n "${dev:-}" ]]; then
    echo "$dev"
    return 0
  fi

  # 3) IPv6 default route (IPv6-only VPS)
  dev="$(ip -6 route show default 2>/dev/null | awk '{for (i=1;i<=NF;i++) if ($i=="dev") {print $(i+1); exit}}' || true)"
  if [[ -n "${dev:-}" ]]; then
    echo "$dev"
    return 0
  fi

  echo ""
}

arch_suffix() {
  local a
  a="$(uname -m)"
  case "$a" in
    x86_64|amd64) echo "amd64" ;;
    aarch64|arm64) echo "arm64" ;;
    *) die "Unsupported arch: $a" ;;
  esac
}

apt_install() {
  export DEBIAN_FRONTEND=noninteractive
  apt-get update -y
  local -a pkgs=(
    ca-certificates
    curl
    gzip
    jq
    iproute2
    iptables
  )
  if [[ "${MODE:-$MODE_DEFAULT}" == "warp" ]]; then
    pkgs+=(wireguard-tools)
  fi
  apt-get install -y --no-install-recommends \
    "${pkgs[@]}"
}

install_wgcf() {
  if has_cmd wgcf; then return 0; fi
  local arch url tmp
  arch="$(arch_suffix)"
  url="https://github.com/ViRb3/wgcf/releases/download/v${WGCF_VERSION}/wgcf_${WGCF_VERSION}_linux_${arch}"
  tmp="$(mktemp)"
  curl -fsSL "$url" -o "$tmp"
  install -m 0755 "$tmp" /usr/local/bin/wgcf
  rm -f "$tmp"
}

install_gost() {
  if has_cmd gost; then return 0; fi
  local arch url tmp
  arch="$(arch_suffix)"
  url="https://github.com/ginuerzh/gost/releases/download/v${GOST_VERSION}/gost-linux-${arch}-${GOST_VERSION}.gz"
  tmp="$(mktemp)"
  curl -fsSL "$url" -o "$tmp"
  gunzip -c "$tmp" >/usr/local/bin/gost
  chmod +x /usr/local/bin/gost
  rm -f "$tmp"
}

ensure_sysctl() {
  cat >"$SYSCTL_FILE" <<'EOFSYS'
net.ipv4.ip_forward=1
EOFSYS
  sysctl --system >/dev/null
}

cfg_path() {
  local i="$1"
  echo "${WG_DIR}/${WG_PREFIX}${i}.conf"
}

state_path() {
  local i="$1"
  echo "${STATE_DIR}/${WG_PREFIX}${i}"
}

ns_name() {
  local i="$1"
  echo "${NS_PREFIX}${i}"
}

subnet_cidr() {
  local i="$1"
  echo "${BASE_NET}.${i}.0/24"
}

host_ip() {
  local i="$1"
  echo "${BASE_NET}.${i}.1"
}

ns_ip() {
  local i="$1"
  echo "${BASE_NET}.${i}.2"
}

veth_host() {
  local i="$1"
  echo "vethw${i}"
}

veth_ns() {
  local i="$1"
  echo "vethn${i}"
}

socks_port() {
  local i="$1"
  echo $((BASE_PORT + i))
}

netns_exists() {
  local ns="$1"
  [[ -e "/run/netns/${ns}" || -e "/var/run/netns/${ns}" ]]
}

ipt() {
  iptables -w 5 "$@"
}

ipt_ensure_top() {
  local table="${1:?}"
  local chain="${2:?}"
  shift 2

  # Remove any duplicates then insert at the top, so we win over generic firewall/NAT rules.
  while ipt -t "$table" -C "$chain" "$@" 2>/dev/null; do
    ipt -t "$table" -D "$chain" "$@" 2>/dev/null || break
  done
  ipt -t "$table" -I "$chain" 1 "$@"
}

strip_wgconf_ipv6() {
  local conf="${1:?}"
  local tmp
  tmp="$(mktemp)"

  if ! awk '
    BEGIN { in_iface=0; in_peer=0; kept_addr=0; kept_allowed=0 }
    /^\[Interface\]$/ { in_iface=1; in_peer=0; print; next }
    /^\[Peer\]$/      { in_peer=1; in_iface=0; print; next }

    # Keep only IPv4 Address entries (supports comma-separated or repeated Address lines).
    in_iface && /^Address[[:space:]]*=/ {
      val=$0
      sub(/^Address[[:space:]]*=[[:space:]]*/, "", val)
      n=split(val, a, /,[[:space:]]*/)
      out=""
      for (i=1;i<=n;i++) {
        if (a[i] ~ /^[0-9.]+\/[0-9]+$/) {
          out = (out=="" ? a[i] : out", "a[i])
        }
      }
      if (out != "") { print "Address = " out; kept_addr=1; next }
      next
    }

    # Keep only IPv4 AllowedIPs entries (supports comma-separated or repeated AllowedIPs lines).
    in_peer && /^AllowedIPs[[:space:]]*=/ {
      val=$0
      sub(/^AllowedIPs[[:space:]]*=[[:space:]]*/, "", val)
      n=split(val, a, /,[[:space:]]*/)
      out=""
      for (i=1;i<=n;i++) {
        if (a[i] ~ /^[0-9.]+\/[0-9]+$/) {
          out = (out=="" ? a[i] : out", "a[i])
        }
      }
      if (out != "") { print "AllowedIPs = " out; kept_allowed=1; next }
      next
    }

    { print }

    END {
      if (kept_addr==0 || kept_allowed==0) exit 2
    }
  ' "$conf" >"$tmp"; then
    rm -f "$tmp"
    return 1
  fi

  cat "$tmp" >"$conf"
  rm -f "$tmp"
}

gen_warp_conf() {
  local i="$1"
  local dir conf
  dir="$(state_path "$i")"
  conf="$(cfg_path "$i")"

  mkdir -p "$dir" "$WG_DIR"

  if [[ -f "$conf" ]]; then
    return 0
  fi

  log "Generating WARP config #$i ..."
  (
    set -euo pipefail
    cd "$dir"
    umask 077
    rm -f wgcf-account.toml wgcf-profile.conf

    attempt=1
    while true; do
      out="$(wgcf register --accept-tos 2>&1)" && break

      if echo "$out" | grep -qE '429 Too Many Requests|401 Unauthorized|403 Forbidden'; then
        if [[ "$attempt" -ge "$REGISTER_RETRIES" ]]; then
          echo "$out" >&2
          exit 42
        fi

        sleep_s=$(( REGISTER_BACKOFF_BASE * (2 ** (attempt - 1)) ))
        if [[ "$sleep_s" -gt "$REGISTER_BACKOFF_MAX" ]]; then sleep_s="$REGISTER_BACKOFF_MAX"; fi

        echo "Cloudflare rejected registration (429/401/403) while registering warp${i}. Waiting ${sleep_s}s then retrying..." >&2
        sleep "$sleep_s"
        attempt=$((attempt + 1))
        continue
      fi

      echo "$out" >&2
      exit 43
    done

    out="$(wgcf generate 2>&1)" || { echo "$out" >&2; exit 44; }
    cp wgcf-profile.conf "$conf"
  )
  rc=$?
  if [[ "$rc" -ne 0 ]]; then
    if [[ "$rc" -eq 42 ]]; then
      die "Cloudflare rejected registration (429/401/403) while creating WARP #$i. Wait 15-60 minutes and re-run: warp-multi install (it will resume), or increase --register-delay / --register-retries / --register-backoff-base."
    fi
    die "Failed to generate WARP config #$i (exit $rc)."
  fi

  # Avoid letting wg-quick manage DNS in host; we'll set netns resolv.conf instead.
  sed -i '/^DNS =/d' "$conf" || true

  # IPv4-only (strip IPv6 Address/AllowedIPs so netns can keep IPv6 disabled).
  strip_wgconf_ipv6 "$conf" || true

  # Keepalive helps on some VPS providers.
  if ! grep -q '^PersistentKeepalive' "$conf"; then
    sed -i '/^\[Peer\]/a PersistentKeepalive = 25' "$conf"
  fi

  chmod 600 "$conf"
}

write_systemd_units() {
  cat >"$UNIT_NETNS" <<'EOFUNIT1'
[Unit]
Description=warp-multi netns %i
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/local/bin/warp-multi ns-up %i
ExecStop=/usr/local/bin/warp-multi ns-down %i

[Install]
WantedBy=multi-user.target
EOFUNIT1

  cat >"$UNIT_SOCKS" <<'EOFUNIT2'
[Unit]
Description=warp-multi SOCKS5 in netns %i
After=warp-netns@%i.service
Requires=warp-netns@%i.service

[Service]
Type=simple
ExecStart=/usr/local/bin/warp-multi socks %i
Restart=on-failure
RestartSec=2

[Install]
WantedBy=multi-user.target
EOFUNIT2

  systemctl daemon-reload
}

cmd_install() {
  # start from defaults
  COUNT="$COUNT_DEFAULT"
  BASE_PORT="$BASE_PORT_DEFAULT"
  BASE_NET="$BASE_NET_DEFAULT"
  NS_PREFIX="$NS_PREFIX_DEFAULT"
  WG_PREFIX="$WG_PREFIX_DEFAULT"
  MODE="$MODE_DEFAULT"
  EGRESS_IPS="$EGRESS_IPS_DEFAULT"
  WGCF_VERSION="$WGCF_VERSION_DEFAULT"
  GOST_VERSION="$GOST_VERSION_DEFAULT"
  REGISTER_DELAY="$REGISTER_DELAY_DEFAULT"
  REGISTER_RETRIES="$REGISTER_RETRIES_DEFAULT"
  REGISTER_BACKOFF_BASE="$REGISTER_BACKOFF_BASE_DEFAULT"
  REGISTER_BACKOFF_MAX="$REGISTER_BACKOFF_MAX_DEFAULT"
  UPLINK_IF=""

  local old_count=""
  if [[ -f "$CONFIG_FILE" ]]; then
    load_config
    old_count="${COUNT:-}"
  fi

  local count_set=0
  local mode_set=0
  local egress_ips_set=0
  local auto_ok=1

  # parse flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --count) COUNT="${2:?}"; count_set=1; auto_ok=0; shift 2 ;;
      --base-port) BASE_PORT="${2:?}"; auto_ok=0; shift 2 ;;
      --base-net) BASE_NET="${2:?}"; auto_ok=0; shift 2 ;;
      --ns-prefix) NS_PREFIX="${2:?}"; auto_ok=0; shift 2 ;;
      --wg-prefix) WG_PREFIX="${2:?}"; auto_ok=0; shift 2 ;;
      --mode) MODE="${2:?}"; mode_set=1; shift 2 ;;
      --egress-ips) EGRESS_IPS="${2:?}"; EGRESS_IPS="${EGRESS_IPS//[[:space:]]/}"; egress_ips_set=1; auto_ok=0; shift 2 ;;
      --snat) MODE="snat"; mode_set=1; shift 1 ;;
      --uplink-if) UPLINK_IF="${2:?}"; shift 2 ;;
      --wgcf-version) WGCF_VERSION="${2:?}"; auto_ok=0; shift 2 ;;
      --gost-version) GOST_VERSION="${2:?}"; auto_ok=0; shift 2 ;;
      --register-delay) REGISTER_DELAY="${2:?}"; auto_ok=0; shift 2 ;;
      --register-retries) REGISTER_RETRIES="${2:?}"; auto_ok=0; shift 2 ;;
      --register-backoff-base) REGISTER_BACKOFF_BASE="${2:?}"; auto_ok=0; shift 2 ;;
      --register-backoff-max) REGISTER_BACKOFF_MAX="${2:?}"; auto_ok=0; shift 2 ;;
      -h|--help) usage_install; exit 0 ;;
      *) die "Unknown flag: $1" ;;
    esac
  done

  require_root

  if [[ "$count_set" -eq 1 ]]; then
    [[ "$COUNT" =~ ^[0-9]+$ ]] || die "--count must be a number"
    [[ "$COUNT" -ge 1 ]] || die "--count must be >= 1"
  fi

  if [[ -z "${UPLINK_IF:-}" ]]; then
    UPLINK_IF="$(detect_uplink)"
  fi
  [[ -n "${UPLINK_IF:-}" ]] || die "Could not detect uplink interface; set with --uplink-if <iface> (hint: ip -4 route show default)"
  ip link show "$UPLINK_IF" >/dev/null 2>&1 || die "Uplink interface '$UPLINK_IF' not found. Pick the interface from: ip -4 route show default"

  # If user provided --egress-ips without --mode, assume SNAT mode.
  if [[ "$egress_ips_set" -eq 1 && "$mode_set" -eq 0 ]]; then
    MODE="snat"
  fi

  # Auto-mode (no flags):
  # If server has >= 2 public IPv4s on the uplink, auto-set COUNT to that number.
  # Also set EGRESS_IPS so each namespace can be SNATed to a different source IPv4.
  if [[ "$auto_ok" -eq 1 && "$count_set" -eq 0 && "$egress_ips_set" -eq 0 ]]; then
    local auto_ips auto_count
    auto_ips="$(detect_egress_ips_csv "$UPLINK_IF")"
    auto_count=0
    if [[ -n "$auto_ips" ]]; then
      local -a auto_arr
      IFS=',' read -r -a auto_arr <<<"$auto_ips"
      auto_count="${#auto_arr[@]}"
    fi
  if [[ "$auto_count" -ge 2 ]]; then
      COUNT="$auto_count"
      EGRESS_IPS="$auto_ips"
      log "Detected ${auto_count} public IPv4 addresses on ${UPLINK_IF}; auto-setting COUNT=${auto_count} (one namespace per IPv4)."
      log "Auto-detected uplink IPv4s: ${EGRESS_IPS}"
    fi
  fi

  [[ "$MODE" == "warp" || "$MODE" == "snat" ]] || die "--mode must be 'warp' or 'snat'"

  if [[ "$MODE" == "snat" ]]; then
    if [[ -z "${EGRESS_IPS:-}" ]]; then
      EGRESS_IPS="$(detect_egress_ips_csv "$UPLINK_IF")"
      [[ -n "${EGRESS_IPS:-}" ]] || die "MODE=snat could not auto-detect any public IPv4 on '$UPLINK_IF'. Provide them explicitly with: --egress-ips A.B.C.D,..."
      log "Auto-detected egress IPv4s on ${UPLINK_IF}: ${EGRESS_IPS}"
    fi
  fi

  if [[ -n "${EGRESS_IPS:-}" ]]; then
    local -a ips_arr
    IFS=',' read -r -a ips_arr <<<"$EGRESS_IPS"
    local ip_count="${#ips_arr[@]}"
    [[ "$ip_count" -ge 1 ]] || die "--egress-ips must include at least 1 IPv4"

    if ! printf '%s\n' "${ips_arr[@]}" | awk 'seen[$0]++ {exit 1}'; then
      die "--egress-ips contains duplicates; provide unique public IPv4s"
    fi

    local ip
    for ip in "${ips_arr[@]}"; do
      is_public_ipv4 "$ip" || die "Invalid public IPv4 in --egress-ips: '$ip'"
      if ! ip -4 addr show dev "$UPLINK_IF" 2>/dev/null | grep -qw "$ip"; then
        warn "Egress IP '$ip' is not configured on uplink interface '$UPLINK_IF' yet. SNAT may fail until you add it."
      fi
    done

    if [[ "$count_set" -eq 0 ]]; then
      COUNT="$ip_count"
    elif [[ "$MODE" == "snat" && "$COUNT" -gt "$ip_count" ]]; then
      die "--count ($COUNT) must be <= number of --egress-ips ($ip_count)"
    elif [[ "$MODE" == "warp" && "$COUNT" -gt "$ip_count" ]]; then
      warn "EGRESS_IPS has ${ip_count} IPs but COUNT=$COUNT; indices >${ip_count} will use MASQUERADE (shared source IPv4)."
    fi
  fi

  [[ "$COUNT" =~ ^[0-9]+$ ]] || die "--count must be a number"
  [[ "$COUNT" -ge 1 ]] || die "--count must be >= 1"
  [[ "$COUNT" -le 200 ]] || warn "High --count ($COUNT). Consider <= 200 to keep routing manageable."

  [[ "$BASE_PORT" =~ ^[0-9]+$ ]] || die "--base-port must be a number"
  [[ "$BASE_PORT" -ge 1024 ]] || warn "--base-port < 1024 needs extra care; continuing anyway."
  local max_port=$((BASE_PORT + COUNT))
  [[ "$max_port" -le 65535 ]] || die "--base-port + --count must be <= 65535 (got ${BASE_PORT}+${COUNT}=${max_port}). Choose a lower --base-port or a smaller --count."

  BASE_NET="$(normalize_base_net "$BASE_NET")"
  if [[ -z "${BASE_NET:-}" ]]; then
    warn "Invalid --base-net value; falling back to default: ${BASE_NET_DEFAULT}"
    BASE_NET="$BASE_NET_DEFAULT"
  fi
  [[ "$BASE_NET" =~ ^[0-9]{1,3}\.[0-9]{1,3}$ ]] || die "--base-net must look like A.B (example: 10.250)"
  local base_a base_b
  base_a="${BASE_NET%%.*}"
  base_b="${BASE_NET##*.}"
  [[ "$base_a" -ge 0 && "$base_a" -le 255 ]] || die "--base-net first octet out of range: ${base_a} (expected 0..255)"
  [[ "$base_b" -ge 0 && "$base_b" -le 255 ]] || die "--base-net second octet out of range: ${base_b} (expected 0..255)"

  [[ "$REGISTER_DELAY" =~ ^[0-9]+$ ]] || die "--register-delay must be a number (seconds)"
  [[ "$REGISTER_RETRIES" =~ ^[0-9]+$ ]] || die "--register-retries must be a number"
  [[ "$REGISTER_RETRIES" -ge 1 ]] || die "--register-retries must be >= 1"
  [[ "$REGISTER_BACKOFF_BASE" =~ ^[0-9]+$ ]] || die "--register-backoff-base must be a number (seconds)"
  [[ "$REGISTER_BACKOFF_BASE" -ge 1 ]] || die "--register-backoff-base must be >= 1"
  [[ "$REGISTER_BACKOFF_MAX" =~ ^[0-9]+$ ]] || die "--register-backoff-max must be a number (seconds)"
  [[ "$REGISTER_BACKOFF_MAX" -ge 1 ]] || die "--register-backoff-max must be >= 1"

  if ! has_cmd apt-get; then
    die "Installer supports Ubuntu/Debian (apt) only."
  fi

  apt_install
  if [[ "$MODE" == "warp" ]]; then
    install_wgcf
  fi
  install_gost
  ensure_sysctl

  save_config

  write_systemd_units

  mkdir -p "$STATE_DIR" "$WG_DIR"
  local i conf
  for i in $(seq 1 "$COUNT"); do
    if [[ "$MODE" == "warp" ]]; then
      conf="$(cfg_path "$i")"
      if [[ ! -f "$conf" ]]; then
        gen_warp_conf "$i"
        if [[ "$REGISTER_DELAY" -gt 0 ]] && [[ "$i" -lt "$COUNT" ]]; then
          sleep "$REGISTER_DELAY"
        fi
      else
        # If user upgrades from an older version, ensure existing configs are IPv4-only too.
        strip_wgconf_ipv6 "$conf" || true
        chmod 600 "$conf" || true
      fi
    fi
    systemctl enable --now "warp-netns@${i}.service" "warp-socks@${i}.service"
  done

  # If count got smaller, stop/disable the old extra services
  if [[ -n "${old_count:-}" ]] && [[ "${old_count}" =~ ^[0-9]+$ ]] && [[ "$old_count" -gt "$COUNT" ]]; then
    for i in $(seq $((COUNT + 1)) "$old_count"); do
      systemctl disable --now "warp-socks@${i}.service" "warp-netns@${i}.service" 2>/dev/null || true
    done
  fi

  log "Installed. SOCKS5 endpoints:"
  cmd_proxies
}

cmd_ns_up() {
  require_root
  load_config

  local i="${1:?}"
  local ns conf sub hostip nsip vh vn
  ns="$(ns_name "$i")"
  conf="$(cfg_path "$i")"
  sub="$(subnet_cidr "$i")"
  hostip="$(host_ip "$i")"
  nsip="$(ns_ip "$i")"
  vh="$(veth_host "$i")"
  vn="$(veth_ns "$i")"

  if [[ "$MODE" == "warp" ]]; then
    [[ -f "$conf" ]] || die "Missing config: $conf (run: warp-multi install)"
  fi

  ip netns del "$ns" 2>/dev/null || true
  ip link del "$vh" 2>/dev/null || true

  ip netns add "$ns"
  ip link add "$vh" type veth peer name "$vn"
  ip link set "$vn" netns "$ns"

  ip addr add "${hostip}/24" dev "$vh"
  ip link set "$vh" up

  ip netns exec "$ns" ip addr add "${nsip}/24" dev "$vn"
  ip netns exec "$ns" ip link set "$vn" up
  ip netns exec "$ns" ip link set lo up

  ip netns exec "$ns" sysctl -q -w \
    net.ipv6.conf.all.disable_ipv6=1 \
    net.ipv6.conf.default.disable_ipv6=1 \
    net.ipv6.conf.lo.disable_ipv6=1 >/dev/null 2>&1 || true

  ip netns exec "$ns" ip route add default via "$hostip"

  mkdir -p "/etc/netns/$ns"
  if [[ ! -f "/etc/netns/$ns/resolv.conf" ]]; then
    cat >"/etc/netns/$ns/resolv.conf" <<'EOFRES'
# generated by warp-multi (edit this file to override DNS for this namespace)
nameserver 1.1.1.1
nameserver 1.0.0.1
EOFRES
  fi

  local egress_ip
  egress_ip="$(egress_ip_for_index "$i")"
  if [[ "$MODE" == "snat" ]]; then
    [[ -n "$egress_ip" ]] || die "MODE=snat requires a matching EGRESS_IPS entry for index $i"
  fi
  if [[ -n "$egress_ip" ]]; then
    ipt_ensure_top nat POSTROUTING -s "$sub" -o "$UPLINK_IF" -j SNAT --to-source "$egress_ip"
  else
    ipt_ensure_top nat POSTROUTING -s "$sub" -o "$UPLINK_IF" -j MASQUERADE
  fi

  ipt_ensure_top filter FORWARD -i "$vh" -o "$UPLINK_IF" -j ACCEPT
  ipt_ensure_top filter FORWARD -i "$UPLINK_IF" -o "$vh" -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT

  if [[ "$MODE" == "warp" ]]; then
    strip_wgconf_ipv6 "$conf" || true
    if ! ip netns exec "$ns" wg-quick up "$conf" >/dev/null; then
      warn "wg-quick up failed for $conf in netns $ns; cleaning up..."
      cmd_ns_down "$i" >/dev/null 2>&1 || true
      die "Failed to bring up WireGuard for $ns ($conf)."
    fi
  fi
}

cmd_ns_down() {
  require_root
  load_config

  local i="${1:?}"
  local ns conf sub vh
  ns="$(ns_name "$i")"
  conf="$(cfg_path "$i")"
  sub="$(subnet_cidr "$i")"
  vh="$(veth_host "$i")"

  if [[ "$MODE" == "warp" ]]; then
    ip netns exec "$ns" wg-quick down "$conf" >/dev/null 2>&1 || true
  fi

  local egress_ip
  egress_ip="$(egress_ip_for_index "$i")"
  if [[ -n "$egress_ip" ]]; then
    ipt -t nat -D POSTROUTING -s "$sub" -o "$UPLINK_IF" -j SNAT --to-source "$egress_ip" 2>/dev/null || true
  fi
  ipt -t nat -D POSTROUTING -s "$sub" -o "$UPLINK_IF" -j MASQUERADE 2>/dev/null || true
  ipt -D FORWARD -i "$vh" -o "$UPLINK_IF" -j ACCEPT 2>/dev/null || true
  ipt -D FORWARD -i "$UPLINK_IF" -o "$vh" -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT 2>/dev/null || true

  ip link del "$vh" 2>/dev/null || true
  ip netns del "$ns" 2>/dev/null || true
}

cmd_socks() {
  require_root
  load_config

  local i="${1:?}"
  local ns nsip port
  ns="$(ns_name "$i")"
  nsip="$(ns_ip "$i")"
  port="$(socks_port "$i")"

  exec ip netns exec "$ns" /usr/local/bin/gost -L "socks5://${nsip}:${port}"
}

cmd_proxies() {
  load_config
  local i
  for i in $(seq 1 "$COUNT"); do
    printf "warp%02d -> %s:%s\n" "$i" "$(ns_ip "$i")" "$(socks_port "$i")"
  done
}

get_exit_ip() {
  local ns="$1"
  if ! netns_exists "$ns"; then
    return 20
  fi
  local tries delay max_time url attempt out ip
  tries="${EXIT_IP_RETRIES:-$EXIT_IP_RETRIES_DEFAULT}"
  delay="${EXIT_IP_DELAY:-$EXIT_IP_DELAY_DEFAULT}"
  max_time="${EXIT_IP_MAX_TIME:-$EXIT_IP_MAX_TIME_DEFAULT}"
  url="${EXIT_IP_URL:-$EXIT_IP_URL_DEFAULT}"

  for attempt in $(seq 1 "$tries"); do
    out="$(ip netns exec "$ns" curl -4 -fsS --max-time "$max_time" "$url" 2>/dev/null || true)"
    ip="$(awk -F= '/^ip=/{print $2; exit}' <<<"$out")"
    if [[ -n "$ip" ]]; then
      echo "$ip"
      return 0
    fi
    if [[ "$attempt" -lt "$tries" ]] && [[ "$delay" -gt 0 ]]; then
      sleep "$delay"
    fi
  done
  return 1
}

cmd_ip() {
  load_config
  local i="${1:?}"
  local ns
  ns="$(ns_name "$i")"
  local ip rc
  if ip="$(get_exit_ip "$ns")"; then
    echo "$ip"
    return 0
  fi
  rc=$?
  if [[ "$rc" -eq 20 ]]; then
    echo "MISSING_NETNS"
  else
    echo "N/A"
  fi
}

cmd_ips() {
  load_config
  local i ns ip
  for i in $(seq 1 "$COUNT"); do
    ns="$(ns_name "$i")"
    printf "warp%02d: " "$i"
    if ip="$(get_exit_ip "$ns")"; then
      echo "$ip"
    else
      if [[ "$?" -eq 20 ]]; then
        echo "MISSING_NETNS"
      else
        echo "N/A"
      fi
    fi
  done
}

cmd_up() {
  require_root
  load_config

  if [[ ! -f "$UNIT_NETNS" || ! -f "$UNIT_SOCKS" ]]; then
    write_systemd_units
  fi

  local i
  for i in $(seq 1 "$COUNT"); do
    systemctl enable --now "warp-netns@${i}.service" "warp-socks@${i}.service"
  done
}

cmd_down() {
  require_root
  load_config

  local i
  for i in $(seq 1 "$COUNT"); do
    systemctl stop "warp-socks@${i}.service" "warp-netns@${i}.service" 2>/dev/null || true
  done
}

cmd_restart() {
  require_root
  load_config

  local which="${1:-all}"
  if [[ "$which" == "all" ]]; then
    local i
    for i in $(seq 1 "$COUNT"); do
      systemctl restart "warp-netns@${i}.service" "warp-socks@${i}.service"
    done
    return 0
  fi

  [[ "$which" =~ ^[0-9]+$ ]] || die "Usage: warp-multi restart <index|all>"
  systemctl restart "warp-netns@${which}.service" "warp-socks@${which}.service"
}

cmd_rotate() {
  require_root
  load_config

  local i="${1:?}"
  [[ "$i" =~ ^[0-9]+$ ]] || die "Usage: warp-multi rotate <index>"
  [[ "$MODE" == "warp" ]] || die "rotate is only available in MODE=warp"

  systemctl stop "warp-socks@${i}.service" "warp-netns@${i}.service" 2>/dev/null || true

  rm -f "$(cfg_path "$i")" || true
  rm -rf "$(state_path "$i")" || true

  gen_warp_conf "$i"

  systemctl start "warp-netns@${i}.service" "warp-socks@${i}.service"

  log "New exit IP for warp$(printf '%02d' "$i"): $(cmd_ip "$i")"
}

cmd_rotate_all() {
  require_root
  load_config

  local i
  for i in $(seq 1 "$COUNT"); do
    cmd_rotate "$i"
    if [[ "${REGISTER_DELAY:-0}" -gt 0 ]] && [[ "$i" -lt "$COUNT" ]]; then
      sleep "$REGISTER_DELAY"
    fi
  done
}

cmd_status() {
  require_root
  load_config

  local i active ip addr port egress
  for i in $(seq 1 "$COUNT"); do
    active="$(systemctl is-active "warp-socks@${i}.service" 2>/dev/null || true)"
    addr="$(ns_ip "$i")"
    port="$(socks_port "$i")"
    ip="$(cmd_ip "$i" 2>/dev/null || true)"
    egress="$(egress_ip_for_index "$i")"
    printf "warp%02d  socks=%s:%s  service=%s  egress_ip=%s  exit_ip=%s\n" \
      "$i" "$addr" "$port" "${active:-unknown}" "${egress:-auto}" "${ip:-N/A}"
  done
}

cmd_check_egress() {
  load_config

  local dev="${UPLINK_IF:-}"
  if [[ -z "$dev" ]]; then
    dev="$(detect_uplink)"
  fi
  [[ -n "$dev" ]] || die "Could not detect uplink interface; set in ${CONFIG_FILE} or run: warp-multi install --uplink-if <iface>"

  local ips="${EGRESS_IPS:-}"
  if [[ -z "$ips" ]]; then
    ips="$(detect_egress_ips_csv "$dev")"
  fi
  [[ -n "$ips" ]] || die "No public IPv4 addresses detected on '${dev}'"

  local -a arr
  IFS=',' read -r -a arr <<<"$ips"

  local ip out seen
  for ip in "${arr[@]}"; do
    out="$(curl -4 --interface "$ip" -fsS --max-time 8 https://cloudflare.com/cdn-cgi/trace 2>/dev/null || true)"
    seen="$(awk -F= '/^ip=/{print $2; exit}' <<<"$out")"
    if [[ -n "$seen" ]]; then
      printf "%s -> %s OK\n" "$ip" "$seen"
    else
      printf "%s -> FAIL\n" "$ip"
    fi
  done
}

cmd_uninstall() {
  require_root
  load_config || true

  local count="${COUNT:-$COUNT_DEFAULT}"
  local i

  for i in $(seq 1 "$count"); do
    local ns
    ns="$(ns_name "$i")"
    systemctl disable --now "warp-socks@${i}.service" "warp-netns@${i}.service" 2>/dev/null || true
    # best-effort cleanup
    cmd_ns_down "$i" 2>/dev/null || true
    rm -f "/etc/netns/${ns}/resolv.conf" 2>/dev/null || true
    rmdir "/etc/netns/${ns}" 2>/dev/null || true
    rm -f "$(cfg_path "$i")" 2>/dev/null || true
    rm -rf "$(state_path "$i")" 2>/dev/null || true
  done

  rm -f "$UNIT_NETNS" "$UNIT_SOCKS" 2>/dev/null || true
  systemctl daemon-reload 2>/dev/null || true

  rm -f "$CONFIG_FILE" 2>/dev/null || true
  rm -rf "$STATE_DIR" 2>/dev/null || true
  rm -f "$SYSCTL_FILE" 2>/dev/null || true
  sysctl --system >/dev/null 2>&1 || true

  log "Uninstalled."
}

usage_install() {
  cat <<EOFU
warp-multi install [options]

Options:
  --mode M           Egress mode: warp|snat (default: ${MODE_DEFAULT})
  --egress-ips CSV   Public IPv4 list for per-namespace SNAT (used as egress IPs in MODE=snat)
  --snat             Shorthand for: --mode snat
  --count N          Number of outbounds (default: ${COUNT_DEFAULT})
  --base-port P      Base port for SOCKS5 (default: ${BASE_PORT_DEFAULT}; ports are P+1..P+N)
  --base-net A.B     Base /16 for veth subnets (default: ${BASE_NET_DEFAULT})
  --uplink-if IFACE  Uplink interface name (auto-detected if not set)
  --ns-prefix STR    Namespace prefix (default: ${NS_PREFIX_DEFAULT})
  --wg-prefix STR    WireGuard config prefix (default: ${WG_PREFIX_DEFAULT})
  --wgcf-version V   wgcf version (default: ${WGCF_VERSION_DEFAULT})
  --gost-version V   gost version (default: ${GOST_VERSION_DEFAULT})
  --register-delay S         Seconds to wait between registrations (default: ${REGISTER_DELAY_DEFAULT})
  --register-retries N       Retries when Cloudflare returns 429 (default: ${REGISTER_RETRIES_DEFAULT})
  --register-backoff-base S  Exponential backoff base seconds (default: ${REGISTER_BACKOFF_BASE_DEFAULT})
  --register-backoff-max S   Max backoff seconds (default: ${REGISTER_BACKOFF_MAX_DEFAULT})

Examples:
  warp-multi install --mode warp --count 10
  warp-multi install --mode warp --count 10 --register-delay 12
  warp-multi install --mode snat --egress-ips 203.0.113.10,203.0.113.11,203.0.113.12,203.0.113.13
  warp-multi install --uplink-if ens3

Notes:
  If you run: warp-multi install
  (no flags) and your server has >= 2 public IPv4 addresses on the uplink interface,
  it will auto-set COUNT to that number and SNAT each namespace to a different uplink IPv4.
EOFU
}

usage() {
  cat <<EOFU
warp-multi v${VERSION}

Commands:
  install [flags]          Install deps, generate configs (warp mode), enable services
  up                       Start/enable all services (does not re-register)
  down                     Stop all services (keeps configs)
  proxies                  Print SOCKS5 endpoints (for x-ui/xray outbounds)
  ip <i>                   Show exit IP for one tunnel
  ips                      Show exit IPs for all tunnels
  status                   Show service status + exit IPs
  check-egress             Test uplink public IPv4 connectivity (curl --interface)
  restart <i|all>          Restart one or all tunnels
  rotate <i>               (warp) Regenerate wgcf account/config for one tunnel (changes keys; usually changes exit IP)
  rotate-all               (warp) Rotate all tunnels
  ns-up <i>                (internal) bring up netns
  ns-down <i>              (internal) bring down netns
  socks <i>                (internal) run SOCKS5 proxy inside netns
  uninstall                Stop services and remove installed files

Config file:
  ${CONFIG_FILE}

Tip (warp mode only, to change exit location/IP sometimes):
  Edit Endpoint in /etc/wireguard/${WG_PREFIX}<i>.conf then:
    warp-multi restart <i>
EOFU
}

main() {
  # Ensure defaults are set even when user runs `warp-multi --help` (no config loaded).
  ensure_defaults

  local cmd="${1:-}"
  shift || true
  case "$cmd" in
    install) cmd_install "$@" ;;
    up) cmd_up "$@" ;;
    down) cmd_down "$@" ;;
    proxies) cmd_proxies "$@" ;;
    ip) cmd_ip "$@" ;;
    ips) cmd_ips "$@" ;;
    status) cmd_status "$@" ;;
    check-egress) cmd_check_egress "$@" ;;
    restart) cmd_restart "$@" ;;
    rotate) cmd_rotate "$@" ;;
    rotate-all) cmd_rotate_all "$@" ;;
    ns-up) cmd_ns_up "$@" ;;
    ns-down) cmd_ns_down "$@" ;;
    socks) cmd_socks "$@" ;;
    uninstall) cmd_uninstall "$@" ;;
    -h|--help|"") usage; exit 0 ;;
    *) die "Unknown command: $cmd (use: warp-multi --help)" ;;
  esac
}

main "$@"

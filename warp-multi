#!/usr/bin/env bash
# warp-multi - Multi Cloudflare WARP egresses (WireGuard) for X-UI / Xray load-balancing
# Works by creating N network namespaces, each with its own WARP WireGuard tunnel and a SOCKS5 proxy.
#
# Ubuntu/Debian (systemd) only.
#
# License: MIT
set -euo pipefail

VERSION="0.1.6"

CONFIG_FILE="/etc/warp-multi.conf"
WG_DIR="/etc/wireguard"
STATE_DIR="/etc/warp-multi"

SYSCTL_FILE="/etc/sysctl.d/99-warp-multi.conf"
UNIT_NETNS="/etc/systemd/system/warp-netns@.service"
UNIT_SOCKS="/etc/systemd/system/warp-socks@.service"

# Defaults (can be set via install flags or by editing CONFIG_FILE)
COUNT_DEFAULT=10
BASE_PORT_DEFAULT=40000
BASE_NET_DEFAULT="10.250" # uses ${BASE_NET}.${i}.0/24
NS_PREFIX_DEFAULT="warp"
WG_PREFIX_DEFAULT="warp"

WGCF_VERSION_DEFAULT="2.2.22"
GOST_VERSION_DEFAULT="2.11.5"

# wgcf register rate-limit handling (Cloudflare may return 429 if you create many accounts fast)
REGISTER_DELAY_DEFAULT=8          # seconds to wait between successful registrations
REGISTER_RETRIES_DEFAULT=8        # retries when 429 happens
REGISTER_BACKOFF_BASE_DEFAULT=15  # exponential backoff base seconds (15,30,60,120,...)
REGISTER_BACKOFF_MAX_DEFAULT=900  # max backoff seconds

# exit IP probing
EXIT_IP_RETRIES_DEFAULT=3
EXIT_IP_DELAY_DEFAULT=1
EXIT_IP_MAX_TIME_DEFAULT=4
EXIT_IP_URL_DEFAULT="https://cloudflare.com/cdn-cgi/trace"

# WireGuard/WARP reachability helpers
WARP_ENDPOINT_HOST_DEFAULT="engage.cloudflareclient.com"
WARP_ENDPOINT_PORTS_DEFAULT="2408,500,1701,4500"
WARP_HANDSHAKE_WAIT_DEFAULT=12
WARP_HANDSHAKE_TRY_WAIT_DEFAULT=6

# Auto-recover dead/stale WARP accounts (only after handshake fails and we already tried endpoints/ports)
AUTORENEW_ON_FAIL_DEFAULT=1
AUTORENEW_MIN_ACCOUNT_AGE_DEFAULT=86400   # seconds (1 day); applies to auto re-register
AUTORENEW_COOLDOWN_DEFAULT=21600          # seconds (6 hours) between auto attempts per tunnel

log() { echo "[$(date +'%F %T')] $*"; }
warn() { echo "WARN: $*" >&2; }
die() { echo "ERROR: $*" >&2; exit 1; }

require_root() {
  [[ "${EUID:-$(id -u)}" -eq 0 ]] || die "Run as root (login as root, or use sudo if it exists)."
}

has_cmd() { command -v "$1" >/dev/null 2>&1; }

is_ipv4() {
  local ip="${1:-}"
  [[ "$ip" =~ ^([0-9]{1,3}\\.){3}[0-9]{1,3}$ ]] || return 1

  local o1 o2 o3 o4
  IFS='.' read -r o1 o2 o3 o4 <<<"$ip"
  for o in "$o1" "$o2" "$o3" "$o4"; do
    [[ "$o" -ge 0 && "$o" -le 255 ]] || return 1
  done
  return 0
}

is_ipv6() {
  local ip="${1:-}"
  [[ "$ip" == *:* ]] || return 1
  [[ "$ip" =~ ^[0-9A-Fa-f:.]+$ ]] || return 1
  return 0
}

normalize_endpoint_host() {
  local host="${1:-}"
  host="${host//[[:space:]]/}"

  # If user mistakenly provided host:port, strip the port.
  if [[ "$host" == *:* ]] && ! is_ipv6 "$host"; then
    host="${host%%:*}"
  fi

  if [[ -z "${host:-}" ]] || is_ipv4 "$host" || is_ipv6 "$host"; then
    echo "$WARP_ENDPOINT_HOST_DEFAULT"
    return 0
  fi
  echo "$host"
}

warp_endpoint_host() {
  normalize_endpoint_host "${WARP_ENDPOINT_HOST:-$WARP_ENDPOINT_HOST_DEFAULT}"
}

resolve_endpoint_ipv4s() {
  local host="${1:?}"
  has_cmd getent || return 1
  getent ahostsv4 "$host" 2>/dev/null | awk '{print $1}' | awk 'NF && !seen[$0]++'
}

pick_endpoint_ipv4_for_index() {
  local i="${1:?}"
  local host="${2:?}"
  local -a ips=()
  mapfile -t ips < <(resolve_endpoint_ipv4s "$host" 2>/dev/null || true)
  [[ "${#ips[@]}" -gt 0 ]] || return 1
  local idx=$(( (i - 1) % ${#ips[@]} ))
  echo "${ips[$idx]}"
}

parse_ports_csv() {
  local csv="${1:-}"
  csv="${csv//[[:space:]]/}"
  local -a raw=()
  IFS=',' read -r -a raw <<<"$csv"
  printf '%s\n' "${raw[@]}" \
    | awk 'NF && $0 ~ /^[0-9]+$/ && $0 >= 1 && $0 <= 65535 && !seen[$0]++'
}

wgconf_endpoint() {
  local conf="${1:?}"
  local ep host port
  ep="$(awk -F= '/^Endpoint[[:space:]]*=/ {print $2; exit}' "$conf" 2>/dev/null | tr -d '[:space:]' || true)"
  host="${ep%:*}"
  port="${ep##*:}"
  if is_ipv4 "$host" && [[ "$port" =~ ^[0-9]+$ ]]; then
    echo "${host}:${port}"
  fi
}

list_active_endpoints() {
  local skip_i="${1:?}"
  local i conf active ep
  for i in $(seq 1 "$COUNT"); do
    [[ "$i" -eq "$skip_i" ]] && continue
    active="$(systemctl is-active "warp-netns@${i}.service" 2>/dev/null || true)"
    [[ "$active" == "active" ]] || continue
    conf="$(cfg_path "$i")"
    [[ -f "$conf" ]] || continue
    ep="$(wgconf_endpoint "$conf" 2>/dev/null || true)"
    [[ -n "${ep:-}" ]] && echo "$ep"
  done
}

pick_endpoint_combo_for_index() {
  local i="${1:?}"
  local host="${2:?}"
  local ports_csv="${3:-}"

  local -a ips=()
  mapfile -t ips < <(resolve_endpoint_ipv4s "$host" 2>/dev/null || true)
  [[ "${#ips[@]}" -gt 0 ]] || return 1

  local -a ports=()
  mapfile -t ports < <(parse_ports_csv "$ports_csv" 2>/dev/null || true)
  [[ "${#ports[@]}" -gt 0 ]] || return 1

  local total=$(( ${#ips[@]} * ${#ports[@]} ))
  local idx=$(( (i - 1) % total ))
  local ip_idx=$(( idx / ${#ports[@]} ))
  local port_idx=$(( idx % ${#ports[@]} ))
  echo "${ips[$ip_idx]}:${ports[$port_idx]}"
}

pick_unused_endpoint_combo() {
  local i="${1:?}"
  local host="${2:?}"
  local ports_csv="${3:-}"

  local -a ips=()
  mapfile -t ips < <(resolve_endpoint_ipv4s "$host" 2>/dev/null || true)
  [[ "${#ips[@]}" -gt 0 ]] || return 1

  local -a ports=()
  mapfile -t ports < <(parse_ports_csv "$ports_csv" 2>/dev/null || true)
  [[ "${#ports[@]}" -gt 0 ]] || return 1

  local total=$(( ${#ips[@]} * ${#ports[@]} ))
  local start=$(( (i - 1) % total ))

  declare -A used=()
  local ep
  while IFS= read -r ep; do
    [[ -n "${ep:-}" ]] || continue
    used["$ep"]=1
  done < <(list_active_endpoints "$i" 2>/dev/null || true)

  local off idx ip_idx port_idx combo
  for off in $(seq 0 $((total - 1))); do
    idx=$(( (start + off) % total ))
    ip_idx=$(( idx / ${#ports[@]} ))
    port_idx=$(( idx % ${#ports[@]} ))
    combo="${ips[$ip_idx]}:${ports[$port_idx]}"
    if [[ -z "${used[$combo]:-}" ]]; then
      echo "$combo"
      return 0
    fi
  done

  ip_idx=$(( start / ${#ports[@]} ))
  port_idx=$(( start % ${#ports[@]} ))
  echo "${ips[$ip_idx]}:${ports[$port_idx]}"
}

ensure_defaults() {
  COUNT="${COUNT:-$COUNT_DEFAULT}"
  BASE_PORT="${BASE_PORT:-$BASE_PORT_DEFAULT}"
  BASE_NET="${BASE_NET:-$BASE_NET_DEFAULT}"
  NS_PREFIX="${NS_PREFIX:-$NS_PREFIX_DEFAULT}"
  WG_PREFIX="${WG_PREFIX:-$WG_PREFIX_DEFAULT}"
  UPLINK_IF="${UPLINK_IF:-}"

  WGCF_VERSION="${WGCF_VERSION:-$WGCF_VERSION_DEFAULT}"
  GOST_VERSION="${GOST_VERSION:-$GOST_VERSION_DEFAULT}"

  REGISTER_DELAY="${REGISTER_DELAY:-$REGISTER_DELAY_DEFAULT}"
  REGISTER_RETRIES="${REGISTER_RETRIES:-$REGISTER_RETRIES_DEFAULT}"
  REGISTER_BACKOFF_BASE="${REGISTER_BACKOFF_BASE:-$REGISTER_BACKOFF_BASE_DEFAULT}"
  REGISTER_BACKOFF_MAX="${REGISTER_BACKOFF_MAX:-$REGISTER_BACKOFF_MAX_DEFAULT}"

  EXIT_IP_RETRIES="${EXIT_IP_RETRIES:-$EXIT_IP_RETRIES_DEFAULT}"
  EXIT_IP_DELAY="${EXIT_IP_DELAY:-$EXIT_IP_DELAY_DEFAULT}"
  EXIT_IP_MAX_TIME="${EXIT_IP_MAX_TIME:-$EXIT_IP_MAX_TIME_DEFAULT}"
  EXIT_IP_URL="${EXIT_IP_URL:-$EXIT_IP_URL_DEFAULT}"

  WARP_ENDPOINT_HOST="${WARP_ENDPOINT_HOST:-$WARP_ENDPOINT_HOST_DEFAULT}"
  WARP_ENDPOINT_HOST="$(normalize_endpoint_host "$WARP_ENDPOINT_HOST")"
  WARP_ENDPOINT_PORTS="${WARP_ENDPOINT_PORTS:-$WARP_ENDPOINT_PORTS_DEFAULT}"
  WARP_HANDSHAKE_WAIT="${WARP_HANDSHAKE_WAIT:-$WARP_HANDSHAKE_WAIT_DEFAULT}"
  WARP_HANDSHAKE_TRY_WAIT="${WARP_HANDSHAKE_TRY_WAIT:-$WARP_HANDSHAKE_TRY_WAIT_DEFAULT}"

  AUTORENEW_ON_FAIL="${AUTORENEW_ON_FAIL:-$AUTORENEW_ON_FAIL_DEFAULT}"
  AUTORENEW_MIN_ACCOUNT_AGE="${AUTORENEW_MIN_ACCOUNT_AGE:-$AUTORENEW_MIN_ACCOUNT_AGE_DEFAULT}"
  AUTORENEW_COOLDOWN="${AUTORENEW_COOLDOWN:-$AUTORENEW_COOLDOWN_DEFAULT}"
}

load_config() {
  if [[ -f "$CONFIG_FILE" ]]; then
    # shellcheck disable=SC1090
    source "$CONFIG_FILE"
  fi
  ensure_defaults
}

save_config() {
  {
    echo "# generated by warp-multi on $(date -Iseconds)"
    printf 'COUNT=%q\n' "$COUNT"
    printf 'BASE_PORT=%q\n' "$BASE_PORT"
    printf 'BASE_NET=%q\n' "$BASE_NET"
    printf 'NS_PREFIX=%q\n' "$NS_PREFIX"
    printf 'WG_PREFIX=%q\n' "$WG_PREFIX"
    printf 'UPLINK_IF=%q\n' "$UPLINK_IF"
    printf 'WGCF_VERSION=%q\n' "$WGCF_VERSION"
    printf 'GOST_VERSION=%q\n' "$GOST_VERSION"
    printf 'REGISTER_DELAY=%q\n' "$REGISTER_DELAY"
    printf 'REGISTER_RETRIES=%q\n' "$REGISTER_RETRIES"
    printf 'REGISTER_BACKOFF_BASE=%q\n' "$REGISTER_BACKOFF_BASE"
    printf 'REGISTER_BACKOFF_MAX=%q\n' "$REGISTER_BACKOFF_MAX"
    printf 'EXIT_IP_RETRIES=%q\n' "$EXIT_IP_RETRIES"
    printf 'EXIT_IP_DELAY=%q\n' "$EXIT_IP_DELAY"
    printf 'EXIT_IP_MAX_TIME=%q\n' "$EXIT_IP_MAX_TIME"
    printf 'EXIT_IP_URL=%q\n' "$EXIT_IP_URL"
    printf 'WARP_ENDPOINT_HOST=%q\n' "$WARP_ENDPOINT_HOST"
    printf 'WARP_ENDPOINT_PORTS=%q\n' "$WARP_ENDPOINT_PORTS"
    printf 'WARP_HANDSHAKE_WAIT=%q\n' "$WARP_HANDSHAKE_WAIT"
    printf 'WARP_HANDSHAKE_TRY_WAIT=%q\n' "$WARP_HANDSHAKE_TRY_WAIT"
    printf 'AUTORENEW_ON_FAIL=%q\n' "$AUTORENEW_ON_FAIL"
    printf 'AUTORENEW_MIN_ACCOUNT_AGE=%q\n' "$AUTORENEW_MIN_ACCOUNT_AGE"
    printf 'AUTORENEW_COOLDOWN=%q\n' "$AUTORENEW_COOLDOWN"
  } >"$CONFIG_FILE"
}

detect_uplink() {
  local dev=""

  # 1) IPv4 default route
  dev="$(ip -4 route show default 2>/dev/null | awk '{for (i=1;i<=NF;i++) if ($i=="dev") {print $(i+1); exit}}' || true)"
  if [[ -n "${dev:-}" ]]; then
    echo "$dev"
    return 0
  fi

  # 2) Route lookup to a well-known IPv4
  dev="$(ip route get 1.1.1.1 2>/dev/null | awk '{for (i=1;i<=NF;i++) if ($i=="dev") {print $(i+1); exit}}' || true)"
  if [[ -n "${dev:-}" ]]; then
    echo "$dev"
    return 0
  fi

  # 3) IPv6 default route (IPv6-only VPS)
  dev="$(ip -6 route show default 2>/dev/null | awk '{for (i=1;i<=NF;i++) if ($i=="dev") {print $(i+1); exit}}' || true)"
  if [[ -n "${dev:-}" ]]; then
    echo "$dev"
    return 0
  fi

  echo ""
}

arch_suffix() {
  local a
  a="$(uname -m)"
  case "$a" in
    x86_64|amd64) echo "amd64" ;;
    aarch64|arm64) echo "arm64" ;;
    *) die "Unsupported arch: $a" ;;
  esac
}

apt_install() {
  export DEBIAN_FRONTEND=noninteractive
  apt-get update -y
  apt-get install -y --no-install-recommends \
    ca-certificates curl gzip jq iproute2 iptables wireguard-tools
}

install_wgcf() {
  if has_cmd wgcf; then return 0; fi
  local arch url tmp
  arch="$(arch_suffix)"
  url="https://github.com/ViRb3/wgcf/releases/download/v${WGCF_VERSION}/wgcf_${WGCF_VERSION}_linux_${arch}"
  tmp="$(mktemp)"
  curl -fsSL "$url" -o "$tmp"
  install -m 0755 "$tmp" /usr/local/bin/wgcf
  rm -f "$tmp"
}

install_gost() {
  if has_cmd gost; then return 0; fi
  local arch url tmp
  arch="$(arch_suffix)"
  url="https://github.com/ginuerzh/gost/releases/download/v${GOST_VERSION}/gost-linux-${arch}-${GOST_VERSION}.gz"
  tmp="$(mktemp)"
  curl -fsSL "$url" -o "$tmp"
  gunzip -c "$tmp" >/usr/local/bin/gost
  chmod +x /usr/local/bin/gost
  rm -f "$tmp"
}

ensure_sysctl() {
  cat >"$SYSCTL_FILE" <<'EOFSYS'
net.ipv4.ip_forward=1
EOFSYS
  sysctl --system >/dev/null
}

cfg_path() {
  local i="$1"
  echo "${WG_DIR}/${WG_PREFIX}${i}.conf"
}

state_path() {
  local i="$1"
  echo "${STATE_DIR}/${WG_PREFIX}${i}"
}

account_created_at_path() {
  local i="$1"
  echo "$(state_path "$i")/created_at"
}

read_epoch_file() {
  local path="${1:?}"
  local ts=""
  if [[ -f "$path" ]]; then
    read -r ts <"$path" 2>/dev/null || true
  fi
  [[ "${ts:-}" =~ ^[0-9]+$ ]] || ts="0"
  echo "$ts"
}

autorenew_marker_path() {
  local i="${1:?}"
  echo "${STATE_DIR}/autorenew/${WG_PREFIX}${i}.ts"
}

autorenew_allowed() {
  [[ "${AUTORENEW_ON_FAIL:-$AUTORENEW_ON_FAIL_DEFAULT}" == "1" ]] || return 1

  local i="${1:?}"
  local now created min_age last cooldown
  now="$(date +%s)"

  created="$(read_epoch_file "$(account_created_at_path "$i")")"
  min_age="${AUTORENEW_MIN_ACCOUNT_AGE:-$AUTORENEW_MIN_ACCOUNT_AGE_DEFAULT}"
  [[ "$min_age" =~ ^[0-9]+$ ]] || min_age="$AUTORENEW_MIN_ACCOUNT_AGE_DEFAULT"
  if [[ "$created" -gt 0 ]] && [[ $((now - created)) -lt "$min_age" ]]; then
    return 1
  fi

  last="$(read_epoch_file "$(autorenew_marker_path "$i")")"
  cooldown="${AUTORENEW_COOLDOWN:-$AUTORENEW_COOLDOWN_DEFAULT}"
  [[ "$cooldown" =~ ^[0-9]+$ ]] || cooldown="$AUTORENEW_COOLDOWN_DEFAULT"
  if [[ "$last" -gt 0 ]] && [[ $((now - last)) -lt "$cooldown" ]]; then
    return 1
  fi

  return 0
}

mark_autorenew_attempt() {
  local i="${1:?}"
  mkdir -p "${STATE_DIR}/autorenew" 2>/dev/null || true
  date +%s >"$(autorenew_marker_path "$i")" 2>/dev/null || true
}

ns_name() {
  local i="$1"
  echo "${NS_PREFIX}${i}"
}

subnet_cidr() {
  local i="$1"
  echo "${BASE_NET}.${i}.0/24"
}

host_ip() {
  local i="$1"
  echo "${BASE_NET}.${i}.1"
}

ns_ip() {
  local i="$1"
  echo "${BASE_NET}.${i}.2"
}

veth_host() {
  local i="$1"
  echo "vethw${i}"
}

veth_ns() {
  local i="$1"
  echo "vethn${i}"
}

socks_port() {
  local i="$1"
  echo $((BASE_PORT + i))
}

netns_exists() {
  local ns="$1"
  [[ -e "/run/netns/${ns}" || -e "/var/run/netns/${ns}" ]]
}

netns_curl() {
  local ns="${1:?}"
  shift || true
  if [[ "${WARP_MULTI_DEBUG:-0}" == "1" ]]; then
    ip netns exec "$ns" curl "$@"
  else
    ip netns exec "$ns" curl "$@" 2>/dev/null
  fi
}

write_netns_resolv_conf() {
  local ns="${1:?}"
  mkdir -p "/etc/netns/$ns"

  local src=""
  if [[ -f "/run/systemd/resolve/resolv.conf" ]]; then
    src="/run/systemd/resolve/resolv.conf"
  elif [[ -f "/etc/resolv.conf" ]]; then
    src="/etc/resolv.conf"
  fi

  local -a servers=()
  local s
  if [[ -n "${src:-}" ]]; then
    while IFS= read -r s; do
      [[ -n "${s:-}" ]] || continue
      if is_ipv4 "$s"; then
        [[ "$s" != 127.* ]] || continue
        [[ "$s" != 169.254.* ]] || continue
      elif is_ipv6 "$s"; then
        [[ "$s" != "::1" ]] || continue
        [[ "$s" != fe80:* ]] || continue
      else
        continue
      fi
      servers+=("$s")
    done < <(awk '/^nameserver[[:space:]]+/ {print $2}' "$src" 2>/dev/null || true)
  fi

  if [[ "${#servers[@]}" -gt 0 ]]; then
    mapfile -t servers < <(printf '%s\n' "${servers[@]}" | awk 'NF && !seen[$0]++')
  fi

  if [[ "${#servers[@]}" -eq 0 ]]; then
    servers=(
      "1.1.1.1"
      "1.0.0.1"
      "8.8.8.8"
      "2606:4700:4700::1111"
      "2606:4700:4700::1001"
      "2001:4860:4860::8888"
    )
  fi

  {
    for s in "${servers[@]}"; do
      echo "nameserver $s"
    done
    echo "options timeout:1 attempts:2"
  } >"/etc/netns/$ns/resolv.conf"
}

ipt() {
  iptables -w 5 "$@"
}

ipt_ensure_top() {
  local table="${1:?}"
  local chain="${2:?}"
  shift 2

  # Remove duplicates then insert at the top to win over generic firewall rules.
  while ipt -t "$table" -C "$chain" "$@" 2>/dev/null; do
    ipt -t "$table" -D "$chain" "$@" 2>/dev/null || break
  done
  ipt -t "$table" -I "$chain" 1 "$@"
}

ipt_delete_all() {
  local table="${1:?}"
  local chain="${2:?}"
  shift 2

  while ipt -t "$table" -C "$chain" "$@" 2>/dev/null; do
    ipt -t "$table" -D "$chain" "$@" 2>/dev/null || break
  done
}

wgconf_peer_pubkey() {
  local conf="${1:?}"
  awk -F= '/^PublicKey[[:space:]]*=/ {gsub(/[[:space:]]/, "", $2); print $2; exit}' "$conf" 2>/dev/null || true
}

set_wgconf_endpoint() {
  local conf="${1:?}"
  local ip="${2:?}"
  local port="${3:?}"
  [[ "$port" =~ ^[0-9]+$ ]] || return 1

  if grep -q '^Endpoint[[:space:]]*=' "$conf" 2>/dev/null; then
    sed -i -E "s|^Endpoint[[:space:]]*=.*|Endpoint = ${ip}:${port}|" "$conf" || true
    return 0
  fi

  # Insert under [Peer] if Endpoint line is missing.
  sed -i "/^\\[Peer\\]$/a Endpoint = ${ip}:${port}" "$conf" || true
  return 0
}

pin_warp_endpoint() {
  local i="${1:?}"
  local conf="${2:?}"

  local cur_ep cur_host cur_port host ports_csv combo ip port
  cur_ep="$(awk -F= '/^Endpoint[[:space:]]*=/ {print $2; exit}' "$conf" 2>/dev/null | tr -d '[:space:]' || true)"
  cur_host="${cur_ep%:*}"
  cur_port="${cur_ep##*:}"
  [[ "$cur_port" =~ ^[0-9]+$ ]] || cur_port="2408"

  # If it's already an IP, keep it.
  if is_ipv4 "$cur_host"; then
    return 0
  fi

  host="$cur_host"
  if [[ -z "${host:-}" ]] || [[ "$host" == "$WARP_ENDPOINT_HOST_DEFAULT" ]]; then
    host="$(warp_endpoint_host)"
  fi
  [[ -n "${host:-}" ]] || return 0

  ports_csv="${WARP_ENDPOINT_PORTS:-$WARP_ENDPOINT_PORTS_DEFAULT},${cur_port}"
  combo="$(pick_endpoint_combo_for_index "$i" "$host" "$ports_csv" 2>/dev/null || true)"
  [[ -n "${combo:-}" ]] || return 0

  ip="${combo%:*}"
  port="${combo##*:}"
  [[ "$port" =~ ^[0-9]+$ ]] || port="$cur_port"
  set_wgconf_endpoint "$conf" "$ip" "$port" || true
}

normalize_warp_conf() {
  local i="${1:?}"
  local conf="${2:?}"

  # Avoid letting wg-quick manage DNS in host; we set netns resolv.conf instead.
  sed -i '/^DNS =/d' "$conf" 2>/dev/null || true

  # Keepalive helps on some VPS providers.
  if ! grep -q '^PersistentKeepalive' "$conf" 2>/dev/null; then
    sed -i '/^\[Peer\]/a PersistentKeepalive = 25' "$conf" 2>/dev/null || true
  fi

  # Pin Endpoint hostname to a real IPv4 to avoid DNS issues inside netns and to spread tunnels across A records.
  pin_warp_endpoint "$i" "$conf" || true

  chmod 600 "$conf" 2>/dev/null || true
}

set_unused_warp_endpoint() {
  local i="${1:?}"
  local conf="${2:?}"

  local host ports_csv combo ip port
  host="$(warp_endpoint_host)"
  ports_csv="${WARP_ENDPOINT_PORTS:-$WARP_ENDPOINT_PORTS_DEFAULT}"

  combo="$(pick_unused_endpoint_combo "$i" "$host" "$ports_csv" 2>/dev/null || true)"
  [[ -n "${combo:-}" ]] || return 0

  ip="${combo%:*}"
  port="${combo##*:}"
  [[ "$port" =~ ^[0-9]+$ ]] || return 0
  set_wgconf_endpoint "$conf" "$ip" "$port" || true
}

gen_warp_conf() {
  local i="$1"
  local dir conf
  dir="$(state_path "$i")"
  conf="$(cfg_path "$i")"

  mkdir -p "$dir" "$WG_DIR"

  if [[ -f "$conf" ]]; then
    normalize_warp_conf "$i" "$conf"
    return 0
  fi

  log "Generating WARP config #$i ..."
  local rc=0
  if (
    set -euo pipefail
    cd "$dir"
    umask 077
    rm -f wgcf-account.toml wgcf-profile.conf

    # Serialize wgcf register/generate across parallel systemd units.
    if command -v flock >/dev/null 2>&1; then
      exec 9>/run/warp-multi-wgcf.lock
      flock -x 9
    fi

    attempt=1
    while true; do
      out="$(wgcf register --accept-tos 2>&1)" && break

      if echo "$out" | grep -qE '429 Too Many Requests|401 Unauthorized|403 Forbidden'; then
        if [[ "$attempt" -ge "$REGISTER_RETRIES" ]]; then
          echo "$out" >&2
          exit 42
        fi

        sleep_s=$(( REGISTER_BACKOFF_BASE * (2 ** (attempt - 1)) ))
        if [[ "$sleep_s" -gt "$REGISTER_BACKOFF_MAX" ]]; then sleep_s="$REGISTER_BACKOFF_MAX"; fi

        echo "Cloudflare rejected registration (429/401/403) while registering warp${i}. Waiting ${sleep_s}s then retrying..." >&2
        sleep "$sleep_s"
        attempt=$((attempt + 1))
        continue
      fi

      echo "$out" >&2
      exit 43
    done

    out="$(wgcf generate 2>&1)" || { echo "$out" >&2; exit 44; }
    cp wgcf-profile.conf "$conf"
    date +%s >created_at
  ); then
    :
  else
    rc=$?
    if [[ "$rc" -eq 42 ]]; then
      die "Cloudflare rejected registration (429/401/403) while creating WARP #$i. Wait 15-60 minutes and re-run: warp-multi install (it will resume), or increase --register-delay / --register-retries / --register-backoff-base."
    fi
    die "Failed to generate WARP config #$i (exit $rc)."
  fi

  normalize_warp_conf "$i" "$conf"
}

write_systemd_units() {
  cat >"$UNIT_NETNS" <<'EOFUNIT1'
[Unit]
Description=WARP netns %i
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
RemainAfterExit=yes
Restart=on-failure
RestartSec=3
TimeoutStartSec=120
ExecStart=/usr/local/bin/warp-multi ns-up %i
ExecStop=/usr/local/bin/warp-multi ns-down %i

[Install]
WantedBy=multi-user.target
EOFUNIT1

  cat >"$UNIT_SOCKS" <<'EOFUNIT2'
[Unit]
Description=WARP SOCKS5 in netns %i
After=warp-netns@%i.service
Requires=warp-netns@%i.service

[Service]
Type=simple
ExecStart=/usr/local/bin/warp-multi socks %i
Restart=on-failure
RestartSec=2

[Install]
WantedBy=multi-user.target
EOFUNIT2

  systemctl daemon-reload
}

cmd_install() {
  require_root

  # start from defaults
  COUNT="$COUNT_DEFAULT"
  BASE_PORT="$BASE_PORT_DEFAULT"
  BASE_NET="$BASE_NET_DEFAULT"
  NS_PREFIX="$NS_PREFIX_DEFAULT"
  WG_PREFIX="$WG_PREFIX_DEFAULT"
  WGCF_VERSION="$WGCF_VERSION_DEFAULT"
  GOST_VERSION="$GOST_VERSION_DEFAULT"
  REGISTER_DELAY="$REGISTER_DELAY_DEFAULT"
  REGISTER_RETRIES="$REGISTER_RETRIES_DEFAULT"
  REGISTER_BACKOFF_BASE="$REGISTER_BACKOFF_BASE_DEFAULT"
  REGISTER_BACKOFF_MAX="$REGISTER_BACKOFF_MAX_DEFAULT"
  EXIT_IP_RETRIES="$EXIT_IP_RETRIES_DEFAULT"
  EXIT_IP_DELAY="$EXIT_IP_DELAY_DEFAULT"
  EXIT_IP_MAX_TIME="$EXIT_IP_MAX_TIME_DEFAULT"
  EXIT_IP_URL="$EXIT_IP_URL_DEFAULT"
  WARP_ENDPOINT_HOST="$WARP_ENDPOINT_HOST_DEFAULT"
  WARP_ENDPOINT_PORTS="$WARP_ENDPOINT_PORTS_DEFAULT"
  WARP_HANDSHAKE_WAIT="$WARP_HANDSHAKE_WAIT_DEFAULT"
  WARP_HANDSHAKE_TRY_WAIT="$WARP_HANDSHAKE_TRY_WAIT_DEFAULT"
  AUTORENEW_ON_FAIL="$AUTORENEW_ON_FAIL_DEFAULT"
  AUTORENEW_MIN_ACCOUNT_AGE="$AUTORENEW_MIN_ACCOUNT_AGE_DEFAULT"
  AUTORENEW_COOLDOWN="$AUTORENEW_COOLDOWN_DEFAULT"
  UPLINK_IF=""

  local old_count=""
  if [[ -f "$CONFIG_FILE" ]]; then
    load_config
    old_count="${COUNT:-}"
  fi

  # parse flags
  local user_set_count=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --count) COUNT="${2:?}"; user_set_count=1; shift 2 ;;
      --base-port) BASE_PORT="${2:?}"; shift 2 ;;
      --base-net) BASE_NET="${2:?}"; shift 2 ;;
      --ns-prefix) NS_PREFIX="${2:?}"; shift 2 ;;
      --wg-prefix) WG_PREFIX="${2:?}"; shift 2 ;;
      --uplink-if) UPLINK_IF="${2:?}"; shift 2 ;;
      --wgcf-version) WGCF_VERSION="${2:?}"; shift 2 ;;
      --gost-version) GOST_VERSION="${2:?}"; shift 2 ;;
      --register-delay) REGISTER_DELAY="${2:?}"; shift 2 ;;
      --register-retries) REGISTER_RETRIES="${2:?}"; shift 2 ;;
      --register-backoff-base) REGISTER_BACKOFF_BASE="${2:?}"; shift 2 ;;
      --register-backoff-max) REGISTER_BACKOFF_MAX="${2:?}"; shift 2 ;;
      -h|--help) usage_install; exit 0 ;;
      *) die "Unknown flag: $1" ;;
    esac
  done

  [[ "$COUNT" =~ ^[0-9]+$ ]] || die "--count must be a number"
  [[ "$COUNT" -ge 1 ]] || die "--count must be >= 1"
  [[ "$COUNT" -le 200 ]] || warn "High --count ($COUNT). Consider <= 200 to keep routing manageable."

  [[ "$BASE_PORT" =~ ^[0-9]+$ ]] || die "--base-port must be a number"
  [[ "$BASE_PORT" -ge 1024 ]] || warn "--base-port < 1024 needs extra care; continuing anyway."

  [[ "$REGISTER_DELAY" =~ ^[0-9]+$ ]] || die "--register-delay must be a number (seconds)"
  [[ "$REGISTER_RETRIES" =~ ^[0-9]+$ ]] || die "--register-retries must be a number"
  [[ "$REGISTER_RETRIES" -ge 1 ]] || die "--register-retries must be >= 1"
  [[ "$REGISTER_BACKOFF_BASE" =~ ^[0-9]+$ ]] || die "--register-backoff-base must be a number (seconds)"
  [[ "$REGISTER_BACKOFF_BASE" -ge 1 ]] || die "--register-backoff-base must be >= 1"
  [[ "$REGISTER_BACKOFF_MAX" =~ ^[0-9]+$ ]] || die "--register-backoff-max must be a number (seconds)"
  [[ "$REGISTER_BACKOFF_MAX" -ge 1 ]] || die "--register-backoff-max must be >= 1"

  if [[ -z "${UPLINK_IF:-}" ]]; then
    UPLINK_IF="$(detect_uplink)"
  fi
  [[ -n "${UPLINK_IF:-}" ]] || die "Could not detect uplink interface; set with --uplink-if <iface> (hint: ip -4 route show default)"
  ip link show "$UPLINK_IF" >/dev/null 2>&1 || die "Uplink interface '$UPLINK_IF' not found. Pick the interface from: ip -4 route show default"

  # If user didn't set --count and we have multiple public IPv4s, default to one tunnel per IPv4.
  if [[ "$user_set_count" -eq 0 ]] && [[ "$COUNT" -eq "$COUNT_DEFAULT" ]]; then
    local ip4_count
    ip4_count="$(ip -4 -o addr show dev "$UPLINK_IF" scope global 2>/dev/null \
      | awk '{print $4}' | cut -d/ -f1 \
      | awk 'NF && !seen[$0]++' | wc -l | tr -d '[:space:]' || true)"
    [[ "${ip4_count:-0}" =~ ^[0-9]+$ ]] || ip4_count=0
    if [[ "$ip4_count" -ge 2 ]]; then
      COUNT="$ip4_count"
      log "Detected ${ip4_count} public IPv4 addresses on ${UPLINK_IF}; auto-setting COUNT=${COUNT}."
    fi
  fi

  if ! has_cmd apt-get; then
    die "Installer supports Ubuntu/Debian (apt) only."
  fi

  apt_install
  install_wgcf
  install_gost
  ensure_sysctl

  save_config

  write_systemd_units

  mkdir -p "$STATE_DIR" "$WG_DIR"
  local i conf
  local start_failed=0
  for i in $(seq 1 "$COUNT"); do
    conf="$(cfg_path "$i")"
    if [[ -f "$conf" ]]; then
      normalize_warp_conf "$i" "$conf"
    else
      gen_warp_conf "$i"
      if [[ "$REGISTER_DELAY" -gt 0 ]] && [[ "$i" -lt "$COUNT" ]]; then
        sleep "$REGISTER_DELAY"
      fi
    fi
    systemctl enable --quiet "warp-netns@${i}.service" "warp-socks@${i}.service" 2>/dev/null || true
    if ! systemctl start --no-block "warp-netns@${i}.service" "warp-socks@${i}.service" >/dev/null 2>&1; then
      start_failed=1
      warn "warp$(printf '%02d' "$i") failed to start via systemd. Check: journalctl -u warp-netns@${i} -e --no-pager"
    fi
  done

  # If count got smaller, stop/disable the old extra services
  if [[ -n "${old_count:-}" ]] && [[ "${old_count}" =~ ^[0-9]+$ ]] && [[ "$old_count" -gt "$COUNT" ]]; then
    for i in $(seq $((COUNT + 1)) "$old_count"); do
      systemctl disable --now "warp-socks@${i}.service" "warp-netns@${i}.service" 2>/dev/null || true
    done
  fi

  log "Installed. SOCKS5 endpoints:"
  cmd_proxies

  if [[ "$start_failed" -eq 1 ]]; then
    warn "Some tunnels didn't start cleanly. systemd will retry (Restart=on-failure). Check: warp-multi status"
  fi
}

wg_latest_handshake_ts() {
  local ns="${1:?}"
  local iface="${2:?}"
  ip netns exec "$ns" wg show "$iface" latest-handshakes 2>/dev/null | awk '{print $2; exit}' 2>/dev/null || true
}

wg_wait_handshake() {
  local ns="${1:?}"
  local iface="${2:?}"
  local timeout_s="${3:-10}"

  [[ "$timeout_s" =~ ^[0-9]+$ ]] || timeout_s=10
  local end now ts
  end=$(( $(date +%s) + timeout_s ))

  while true; do
    ts="$(wg_latest_handshake_ts "$ns" "$iface" 2>/dev/null || echo 0)"
    if [[ "${ts:-0}" -gt 0 ]]; then
      return 0
    fi
    now="$(date +%s)"
    [[ "$now" -lt "$end" ]] || break
    sleep 1
  done
  return 1
}

warp_trigger_traffic() {
  local ns="${1:?}"
  ip netns exec "$ns" bash -c 'echo -n x >/dev/udp/1.1.1.1/53' >/dev/null 2>&1 || true
  ip netns exec "$ns" bash -c 'echo -n x >/dev/udp/8.8.8.8/53' >/dev/null 2>&1 || true
}

warp_try_fix_handshake() {
  local i="${1:?}"
  local ns="${2:?}"
  local conf="${3:?}"

  local iface peer
  iface="${WG_PREFIX}${i}"
  peer="$(wgconf_peer_pubkey "$conf")"
  [[ -n "${peer:-}" ]] || return 1

  local wait_s="${WARP_HANDSHAKE_WAIT:-$WARP_HANDSHAKE_WAIT_DEFAULT}"
  [[ "$wait_s" =~ ^[0-9]+$ ]] || wait_s="$WARP_HANDSHAKE_WAIT_DEFAULT"

  # Wait a bit for initial handshake (especially right after boot).
  warp_trigger_traffic "$ns"
  if wg_wait_handshake "$ns" "$iface" "$wait_s"; then
    return 0
  fi

  local cur_ep cur_host cur_port
  cur_ep="$(awk -F= '/^Endpoint[[:space:]]*=/ {print $2; exit}' "$conf" 2>/dev/null | tr -d '[:space:]' || true)"
  cur_host="${cur_ep%:*}"
  cur_port="${cur_ep##*:}"
  [[ "$cur_port" =~ ^[0-9]+$ ]] || cur_port="2408"

  local host="$cur_host"
  if [[ -z "${host:-}" ]] || is_ipv4 "$host"; then
    host="$(warp_endpoint_host)"
  fi
  [[ -n "${host:-}" ]] || host="$WARP_ENDPOINT_HOST_DEFAULT"

  local -a ips=()
  local ip preferred
  if is_ipv4 "$cur_host"; then
    ips+=("$cur_host")
  fi
  preferred="$(pick_endpoint_ipv4_for_index "$i" "$host" 2>/dev/null || true)"
  [[ -n "${preferred:-}" ]] && ips+=("$preferred")
  while IFS= read -r ip; do
    [[ -n "$ip" ]] || continue
    ips+=("$ip")
  done < <(resolve_endpoint_ipv4s "$host" 2>/dev/null || true)

  if [[ "${#ips[@]}" -gt 0 ]]; then
    mapfile -t ips < <(printf '%s\n' "${ips[@]}" | awk 'NF && !seen[$0]++')
  fi

  local ports_csv ports_csv_nospace
  ports_csv="${WARP_ENDPOINT_PORTS:-$WARP_ENDPOINT_PORTS_DEFAULT}"
  ports_csv_nospace="${ports_csv//[[:space:]]/}"
  local -a ports_raw=()
  local -a ports=()
  local p
  IFS=',' read -r -a ports_raw <<<"$ports_csv_nospace"
  ports_raw+=("$cur_port")
  mapfile -t ports < <(printf '%s\n' "${ports_raw[@]}" \
    | awk 'NF && $0 ~ /^[0-9]+$/ && $0 >= 1 && $0 <= 65535 && !seen[$0]++')

  [[ "${#ips[@]}" -gt 0 ]] || return 1
  [[ "${#ports[@]}" -gt 0 ]] || return 1

  local try_wait="${WARP_HANDSHAKE_TRY_WAIT:-$WARP_HANDSHAKE_TRY_WAIT_DEFAULT}"
  [[ "$try_wait" =~ ^[0-9]+$ ]] || try_wait="$WARP_HANDSHAKE_TRY_WAIT_DEFAULT"

  for p in "${ports[@]}"; do
    for ip in "${ips[@]}"; do
      [[ -n "$ip" ]] || continue
      set_wgconf_endpoint "$conf" "$ip" "$p" || true
      ip netns exec "$ns" wg set "$iface" peer "$peer" endpoint "${ip}:${p}" 2>/dev/null || true
      warp_trigger_traffic "$ns"
      if wg_wait_handshake "$ns" "$iface" "$try_wait"; then
        log "warp$(printf '%02d' "$i") handshake OK via Endpoint=${ip}:${p}"
        return 0
      fi
    done
  done

  warn "warp$(printf '%02d' "$i") has no handshake after trying endpoints/ports (host=${host}, ports=${ports_csv_nospace})."
  return 1
}

cmd_ns_up() {
  require_root
  load_config

  local i="${1:?}"
  local ns conf sub hostip nsip vh vn
  ns="$(ns_name "$i")"
  conf="$(cfg_path "$i")"
  sub="$(subnet_cidr "$i")"
  hostip="$(host_ip "$i")"
  nsip="$(ns_ip "$i")"
  vh="$(veth_host "$i")"
  vn="$(veth_ns "$i")"

  [[ -f "$conf" ]] || die "Missing config: $conf (run: warp-multi install)"
  normalize_warp_conf "$i" "$conf"

  ip netns del "$ns" 2>/dev/null || true
  ip link del "$vh" 2>/dev/null || true

  ip netns add "$ns"
  ip link add "$vh" type veth peer name "$vn"
  ip link set "$vn" netns "$ns"

  ip addr add "${hostip}/24" dev "$vh"
  ip link set "$vh" up

  ip netns exec "$ns" ip addr add "${nsip}/24" dev "$vn"
  ip netns exec "$ns" ip link set "$vn" up
  ip netns exec "$ns" ip link set lo up

  # Ensure IPv6 is enabled inside the namespace (WARP often provides IPv6 even on IPv4-only servers).
  ip netns exec "$ns" sysctl -q -w \
    net.ipv6.conf.all.disable_ipv6=0 \
    net.ipv6.conf.default.disable_ipv6=0 \
    net.ipv6.conf.lo.disable_ipv6=0 >/dev/null 2>&1 || true

  ip netns exec "$ns" ip route add default via "$hostip"

  write_netns_resolv_conf "$ns"

  ipt_ensure_top nat POSTROUTING -s "$sub" -o "$UPLINK_IF" -j MASQUERADE
  ipt_ensure_top filter FORWARD -i "$vh" -o "$UPLINK_IF" -j ACCEPT
  ipt_ensure_top filter FORWARD -i "$UPLINK_IF" -o "$vh" -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT

  ip netns exec "$ns" wg-quick up "$conf" >/dev/null

  # If the tunnel doesn't handshake, fail the unit so systemd doesn't mark it active.
  if ! warp_try_fix_handshake "$i" "$ns" "$conf"; then
    # If this is a stale/dead WARP account, try one auto re-register/renew (rate-limit guarded).
    if autorenew_allowed "$i"; then
      warn "warp$(printf '%02d' "$i") handshake failed; attempting auto renew (wgcf re-register) once."
      mark_autorenew_attempt "$i"

      if (
        set -euo pipefail
        ip netns exec "$ns" wg-quick down "$conf" >/dev/null 2>&1 || true
        rm -f "$conf" 2>/dev/null || true
        rm -rf "$(state_path "$i")" 2>/dev/null || true

        gen_warp_conf "$i"
        conf="$(cfg_path "$i")"
        set_unused_warp_endpoint "$i" "$conf" || true

        ip netns exec "$ns" wg-quick up "$conf" >/dev/null
        warp_try_fix_handshake "$i" "$ns" "$conf"
      ); then
        return 0
      fi
    fi

    warn "warp$(printf '%02d' "$i") handshake failed; cleaning up netns."
    cmd_ns_down "$i" 2>/dev/null || true
    die "warp$(printf '%02d' "$i") has no WireGuard handshake. Try: warp-multi rotate $i"
  fi
}

cmd_ns_down() {
  require_root
  load_config

  local i="${1:?}"
  local ns conf sub vh
  ns="$(ns_name "$i")"
  conf="$(cfg_path "$i")"
  sub="$(subnet_cidr "$i")"
  vh="$(veth_host "$i")"

  ip netns exec "$ns" wg-quick down "$conf" >/dev/null 2>&1 || true

  ipt_delete_all nat POSTROUTING -s "$sub" -o "$UPLINK_IF" -j MASQUERADE
  ipt_delete_all filter FORWARD -i "$vh" -o "$UPLINK_IF" -j ACCEPT
  ipt_delete_all filter FORWARD -i "$UPLINK_IF" -o "$vh" -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
  ipt_delete_all filter FORWARD -i "$UPLINK_IF" -o "$vh" -m state --state RELATED,ESTABLISHED -j ACCEPT

  ip link del "$vh" 2>/dev/null || true
  ip netns del "$ns" 2>/dev/null || true
}

cmd_socks() {
  require_root
  load_config

  local i="${1:?}"
  local ns nsip port
  ns="$(ns_name "$i")"
  nsip="$(ns_ip "$i")"
  port="$(socks_port "$i")"

  exec ip netns exec "$ns" /usr/local/bin/gost -L "socks5://${nsip}:${port}"
}

cmd_proxies() {
  load_config
  local i
  for i in $(seq 1 "$COUNT"); do
    printf "warp%02d -> %s:%s\n" "$i" "$(ns_ip "$i")" "$(socks_port "$i")"
  done
}

get_exit_ip() {
  local ns="$1"
  if ! netns_exists "$ns"; then
    return 20
  fi

  local retries delay max_time url
  retries="${EXIT_IP_RETRIES:-$EXIT_IP_RETRIES_DEFAULT}"
  delay="${EXIT_IP_DELAY:-$EXIT_IP_DELAY_DEFAULT}"
  max_time="${EXIT_IP_MAX_TIME:-$EXIT_IP_MAX_TIME_DEFAULT}"
  url="${EXIT_IP_URL:-$EXIT_IP_URL_DEFAULT}"

  [[ "$retries" =~ ^[0-9]+$ ]] || retries="$EXIT_IP_RETRIES_DEFAULT"
  [[ "$delay" =~ ^[0-9]+$ ]] || delay="$EXIT_IP_DELAY_DEFAULT"
  [[ "$max_time" =~ ^[0-9]+$ ]] || max_time="$EXIT_IP_MAX_TIME_DEFAULT"
  [[ -n "${url:-}" ]] || url="$EXIT_IP_URL_DEFAULT"

  [[ "$retries" -ge 1 ]] || retries=1

  # Prefer IPv6 (WARP usually provides it even on IPv4-only servers); fall back to IPv4.
  local attempt out ip
  for attempt in $(seq 1 "$retries"); do
    if out="$(netns_curl "$ns" -6 -fsS --max-time "$max_time" "$url")"; then
      ip="$(awk -F= '/^ip=/{print $2; exit}' <<<"$out" 2>/dev/null || true)"
      if [[ -n "${ip:-}" ]]; then
        echo "$ip"
        return 0
      fi
    fi

    if out="$(netns_curl "$ns" -4 -fsS --max-time "$max_time" "$url")"; then
      ip="$(awk -F= '/^ip=/{print $2; exit}' <<<"$out" 2>/dev/null || true)"
      if [[ -n "${ip:-}" ]]; then
        echo "$ip"
        return 0
      fi
    fi

    if [[ "$attempt" -lt "$retries" ]] && [[ "$delay" -gt 0 ]]; then
      sleep "$delay"
    fi
  done

  return 1
}

cmd_ip() {
  load_config
  local i="${1:?}"
  local ns
  ns="$(ns_name "$i")"
  local ip rc
  ip="$(get_exit_ip "$ns")"
  rc=$?
  if [[ "$rc" -eq 0 ]]; then
    echo "$ip"
    return 0
  fi
  if [[ "$rc" -eq 20 ]]; then
    echo "MISSING_NETNS"
  else
    echo "N/A"
  fi
}

cmd_ips() {
  load_config
  local i ns ip rc
  for i in $(seq 1 "$COUNT"); do
    ns="$(ns_name "$i")"
    printf "warp%02d: " "$i"
    ip="$(get_exit_ip "$ns")"
    rc=$?
    if [[ "$rc" -eq 0 ]]; then
      echo "$ip"
    else
      if [[ "$rc" -eq 20 ]]; then
        echo "MISSING_NETNS"
      else
        echo "N/A"
      fi
    fi
  done
}

cmd_up() {
  require_root
  load_config

  if [[ ! -f "$UNIT_NETNS" || ! -f "$UNIT_SOCKS" ]]; then
    write_systemd_units
  fi

  local i
  for i in $(seq 1 "$COUNT"); do
    systemctl enable --quiet "warp-netns@${i}.service" "warp-socks@${i}.service" 2>/dev/null || true
    systemctl start --no-block "warp-netns@${i}.service" "warp-socks@${i}.service" >/dev/null 2>&1 || true
  done
}

cmd_down() {
  require_root
  load_config

  local i
  for i in $(seq 1 "$COUNT"); do
    systemctl stop "warp-socks@${i}.service" "warp-netns@${i}.service" 2>/dev/null || true
  done
}

cmd_restart() {
  require_root
  load_config

  local which="${1:-all}"
  if [[ "$which" == "all" ]]; then
    local i
    for i in $(seq 1 "$COUNT"); do
      systemctl restart "warp-netns@${i}.service" "warp-socks@${i}.service"
    done
    return 0
  fi

  [[ "$which" =~ ^[0-9]+$ ]] || die "Usage: warp-multi restart <index|all>"
  systemctl restart "warp-netns@${which}.service" "warp-socks@${which}.service"
}

cmd_rotate() {
  require_root
  load_config

  local i="${1:?}"
  [[ "$i" =~ ^[0-9]+$ ]] || die "Usage: warp-multi rotate <index>"

  systemctl stop "warp-socks@${i}.service" "warp-netns@${i}.service" 2>/dev/null || true

  rm -f "$(cfg_path "$i")" || true
  rm -rf "$(state_path "$i")" || true

  gen_warp_conf "$i"
  set_unused_warp_endpoint "$i" "$(cfg_path "$i")" || true

  systemctl start "warp-netns@${i}.service" "warp-socks@${i}.service"

  sleep 2
  log "New exit IP for warp$(printf '%02d' "$i"): $(cmd_ip "$i")"
}

cmd_renew() {
  require_root
  load_config

  local i="${1:?}"
  [[ "$i" =~ ^[0-9]+$ ]] || die "Usage: warp-multi renew <index>"

  local ns conf
  ns="$(ns_name "$i")"
  conf="$(cfg_path "$i")"

  if ! netns_exists "$ns"; then
    warn "Namespace '$ns' is missing; falling back to rotate (will restart SOCKS)."
    cmd_rotate "$i"
    return 0
  fi
  [[ -f "$conf" ]] || die "Missing config: $conf (run: warp-multi install)"

  local tmp old_conf old_state state_dir
  tmp="$(mktemp -d)"
  old_conf="${tmp}/old.conf"
  old_state="${tmp}/old_state"
  state_dir="$(state_path "$i")"

  cp -f "$conf" "$old_conf" 2>/dev/null || true
  if [[ -d "$state_dir" ]]; then
    cp -a "$state_dir" "$old_state" 2>/dev/null || true
  fi

  if (
    set -euo pipefail
    ip netns exec "$ns" wg-quick down "$conf" >/dev/null 2>&1 || true
    rm -f "$conf" 2>/dev/null || true
    rm -rf "$state_dir" 2>/dev/null || true

    gen_warp_conf "$i"
    conf="$(cfg_path "$i")"
    set_unused_warp_endpoint "$i" "$conf" || true

    ip netns exec "$ns" wg-quick up "$conf" >/dev/null
    warp_try_fix_handshake "$i" "$ns" "$conf"
  ); then
    rm -rf "$tmp" 2>/dev/null || true
    log "New exit IP for warp$(printf '%02d' "$i"): $(cmd_ip "$i")"
    return 0
  fi

  warn "warp$(printf '%02d' "$i") renew failed; restoring previous config."
  if [[ -f "$old_conf" ]]; then
    cp -f "$old_conf" "$conf" 2>/dev/null || true
    normalize_warp_conf "$i" "$conf" || true
  fi
  if [[ -d "$old_state" ]]; then
    rm -rf "$state_dir" 2>/dev/null || true
    cp -a "$old_state" "$state_dir" 2>/dev/null || true
  fi

  # Best-effort: bring the old tunnel back up.
  ip netns exec "$ns" wg-quick down "$conf" >/dev/null 2>&1 || true
  ip netns exec "$ns" wg-quick up "$conf" >/dev/null 2>&1 || true
  warp_try_fix_handshake "$i" "$ns" "$conf" 2>/dev/null || true

  rm -rf "$tmp" 2>/dev/null || true
  die "warp$(printf '%02d' "$i") renew failed (restored previous config)."
}

cmd_renew_all() {
  require_root
  load_config

  local i
  for i in $(seq 1 "$COUNT"); do
    cmd_renew "$i"
    if [[ "${REGISTER_DELAY:-0}" -gt 0 ]] && [[ "$i" -lt "$COUNT" ]]; then
      sleep "$REGISTER_DELAY"
    fi
  done
}

cmd_rotate_all() {
  require_root
  load_config

  local i
  for i in $(seq 1 "$COUNT"); do
    cmd_rotate "$i"
    if [[ "${REGISTER_DELAY:-0}" -gt 0 ]] && [[ "$i" -lt "$COUNT" ]]; then
      sleep "$REGISTER_DELAY"
    fi
  done
}

cmd_status() {
  require_root
  load_config

  local i active ip addr port
  for i in $(seq 1 "$COUNT"); do
    active="$(systemctl is-active "warp-socks@${i}.service" 2>/dev/null || true)"
    addr="$(ns_ip "$i")"
    port="$(socks_port "$i")"
    ip="$(cmd_ip "$i" 2>/dev/null || true)"
    printf "warp%02d  socks=%s:%s  service=%s  exit_ip=%s\n" "$i" "$addr" "$port" "${active:-unknown}" "${ip:-N/A}"
  done
}

cmd_uninstall() {
  require_root
  load_config || true

  local count="${COUNT:-$COUNT_DEFAULT}"
  local i

  for i in $(seq 1 "$count"); do
    systemctl disable --now "warp-socks@${i}.service" "warp-netns@${i}.service" 2>/dev/null || true
    # best-effort cleanup
    cmd_ns_down "$i" 2>/dev/null || true
    rm -f "$(cfg_path "$i")" 2>/dev/null || true
    rm -rf "$(state_path "$i")" 2>/dev/null || true
  done

  rm -f "$UNIT_NETNS" "$UNIT_SOCKS" 2>/dev/null || true
  systemctl daemon-reload 2>/dev/null || true

  rm -f "$CONFIG_FILE" 2>/dev/null || true
  rm -rf "$STATE_DIR" 2>/dev/null || true
  rm -f "$SYSCTL_FILE" 2>/dev/null || true
  sysctl --system >/dev/null 2>&1 || true

  log "Uninstalled."
}

usage_install() {
  cat <<EOFU
warp-multi install [options]

Options:
  --count N          Number of WARP outbounds (default: ${COUNT_DEFAULT})
  --base-port P      Base port for SOCKS5 (default: ${BASE_PORT_DEFAULT}; ports are P+1..P+N)
  --base-net A.B     Base /16 for veth subnets (default: ${BASE_NET_DEFAULT})
  --uplink-if IFACE  Uplink interface name (auto-detected if not set)
  --ns-prefix STR    Namespace prefix (default: ${NS_PREFIX_DEFAULT})
  --wg-prefix STR    WireGuard config prefix (default: ${WG_PREFIX_DEFAULT})
  --wgcf-version V   wgcf version (default: ${WGCF_VERSION_DEFAULT})
  --gost-version V   gost version (default: ${GOST_VERSION_DEFAULT})
  --register-delay S         Seconds to wait between registrations (default: ${REGISTER_DELAY_DEFAULT})
  --register-retries N       Retries when Cloudflare returns 429 (default: ${REGISTER_RETRIES_DEFAULT})
  --register-backoff-base S  Exponential backoff base seconds (default: ${REGISTER_BACKOFF_BASE_DEFAULT})
  --register-backoff-max S   Max backoff seconds (default: ${REGISTER_BACKOFF_MAX_DEFAULT})

Examples:
  warp-multi install
  warp-multi install --count 10 --base-port 40000 --base-net 10.250
  warp-multi install --uplink-if ens3
  warp-multi install --count 10 --register-delay 12
EOFU
}

usage() {
  cat <<EOFU
warp-multi v${VERSION}

Commands:
  install [flags]          Install deps, generate configs, enable services
  up                       Start/enable all services (does not re-register)
  down                     Stop all services (keeps configs)
  proxies                  Print SOCKS5 endpoints (for x-ui/xray outbounds)
  ip <i>                   Show exit IP for one tunnel
  ips                      Show exit IPs for all tunnels
  status                   Show service status + exit IPs
  restart <i|all>          Restart one or all tunnels
  rotate <i>               Regenerate wgcf account/config for one tunnel (changes keys; usually changes exit IP)
  rotate-all               Rotate all tunnels
  renew <i>                Re-register WARP for one tunnel without restarting SOCKS (keeps netns)
  renew-all                Renew all tunnels
  ns-up <i>                (internal) bring up netns + wg
  ns-down <i>              (internal) bring down netns + wg
  socks <i>                (internal) run SOCKS5 proxy inside netns
  uninstall                Stop services and remove installed files

Config file:
  ${CONFIG_FILE}

Tip (to change exit location/IP sometimes):
  Edit Endpoint in /etc/wireguard/${WG_PREFIX}<i>.conf then:
    warp-multi restart <i>
EOFU
}

main() {
  # Ensure defaults are set even when user runs `warp-multi --help` (no config loaded).
  ensure_defaults

  local cmd="${1:-}"
  shift || true
  case "$cmd" in
    install) cmd_install "$@" ;;
    up) cmd_up "$@" ;;
    down) cmd_down "$@" ;;
    proxies) cmd_proxies "$@" ;;
    ip) cmd_ip "$@" ;;
    ips) cmd_ips "$@" ;;
    status) cmd_status "$@" ;;
    restart) cmd_restart "$@" ;;
    rotate) cmd_rotate "$@" ;;
    rotate-all) cmd_rotate_all "$@" ;;
    renew) cmd_renew "$@" ;;
    renew-all) cmd_renew_all "$@" ;;
    ns-up) cmd_ns_up "$@" ;;
    ns-down) cmd_ns_down "$@" ;;
    socks) cmd_socks "$@" ;;
    uninstall) cmd_uninstall "$@" ;;
    -h|--help|"") usage; exit 0 ;;
    *) die "Unknown command: $cmd (use: warp-multi --help)" ;;
  esac
}

main "$@"

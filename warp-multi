#!/usr/bin/env bash
# warp-multi - Multi Cloudflare WARP egresses (WireGuard) for X-UI / Xray load-balancing
# Works by creating N network namespaces, each with its own WARP WireGuard tunnel and a SOCKS5 proxy.
#
# Ubuntu/Debian (systemd) only.
#
# License: MIT
set -euo pipefail

VERSION="0.1.0"

CONFIG_FILE="/etc/warp-multi.conf"
WG_DIR="/etc/wireguard"
STATE_DIR="/etc/warp-multi"

SYSCTL_FILE="/etc/sysctl.d/99-warp-multi.conf"
UNIT_NETNS="/etc/systemd/system/warp-netns@.service"
UNIT_SOCKS="/etc/systemd/system/warp-socks@.service"

# Defaults (can be set via install flags or by editing CONFIG_FILE)
COUNT_DEFAULT=10
BASE_PORT_DEFAULT=40000
BASE_NET_DEFAULT="10.250" # uses ${BASE_NET}.${i}.0/24
NS_PREFIX_DEFAULT="warp"
WG_PREFIX_DEFAULT="warp"

WGCF_VERSION_DEFAULT="2.2.22"
GOST_VERSION_DEFAULT="2.11.5"

# wgcf register rate-limit handling (Cloudflare may return 429 if you create many accounts fast)
REGISTER_DELAY_DEFAULT=8          # seconds to wait between successful registrations
REGISTER_RETRIES_DEFAULT=8        # retries when 429 happens
REGISTER_BACKOFF_BASE_DEFAULT=15  # exponential backoff base seconds (15,30,60,120,...)
REGISTER_BACKOFF_MAX_DEFAULT=900  # max backoff seconds

log() { echo "[$(date +'%F %T')] $*"; }
warn() { echo "WARN: $*" >&2; }
die() { echo "ERROR: $*" >&2; exit 1; }

require_root() { [[ "${EUID:-$(id -u)}" -eq 0 ]] || die "Run as root (sudo -i)"; }

has_cmd() { command -v "$1" >/dev/null 2>&1; }

ensure_defaults() {
  COUNT="${COUNT:-$COUNT_DEFAULT}"
  BASE_PORT="${BASE_PORT:-$BASE_PORT_DEFAULT}"
  BASE_NET="${BASE_NET:-$BASE_NET_DEFAULT}"
  NS_PREFIX="${NS_PREFIX:-$NS_PREFIX_DEFAULT}"
  WG_PREFIX="${WG_PREFIX:-$WG_PREFIX_DEFAULT}"
  UPLINK_IF="${UPLINK_IF:-}"

  WGCF_VERSION="${WGCF_VERSION:-$WGCF_VERSION_DEFAULT}"
  GOST_VERSION="${GOST_VERSION:-$GOST_VERSION_DEFAULT}"

  REGISTER_DELAY="${REGISTER_DELAY:-$REGISTER_DELAY_DEFAULT}"
  REGISTER_RETRIES="${REGISTER_RETRIES:-$REGISTER_RETRIES_DEFAULT}"
  REGISTER_BACKOFF_BASE="${REGISTER_BACKOFF_BASE:-$REGISTER_BACKOFF_BASE_DEFAULT}"
  REGISTER_BACKOFF_MAX="${REGISTER_BACKOFF_MAX:-$REGISTER_BACKOFF_MAX_DEFAULT}"
}

load_config() {
  if [[ -f "$CONFIG_FILE" ]]; then
    # shellcheck disable=SC1090
    source "$CONFIG_FILE"
  fi
  ensure_defaults
}

save_config() {
  cat >"$CONFIG_FILE" <<EOFCONF
# generated by warp-multi on $(date -Iseconds)
COUNT=${COUNT}
BASE_PORT=${BASE_PORT}
BASE_NET=${BASE_NET}
NS_PREFIX=${NS_PREFIX}
WG_PREFIX=${WG_PREFIX}
UPLINK_IF=${UPLINK_IF}
WGCF_VERSION=${WGCF_VERSION}
GOST_VERSION=${GOST_VERSION}
REGISTER_DELAY=${REGISTER_DELAY}
REGISTER_RETRIES=${REGISTER_RETRIES}
REGISTER_BACKOFF_BASE=${REGISTER_BACKOFF_BASE}
REGISTER_BACKOFF_MAX=${REGISTER_BACKOFF_MAX}
EOFCONF
}

detect_uplink() {
  local dev=""

  # 1) IPv4 default route
  dev="$(ip -4 route show default 2>/dev/null | awk '{for (i=1;i<=NF;i++) if ($i=="dev") {print $(i+1); exit}}' || true)"
  if [[ -n "${dev:-}" ]]; then
    echo "$dev"
    return 0
  fi

  # 2) Route lookup to a well-known IPv4
  dev="$(ip route get 1.1.1.1 2>/dev/null | awk '{for (i=1;i<=NF;i++) if ($i=="dev") {print $(i+1); exit}}' || true)"
  if [[ -n "${dev:-}" ]]; then
    echo "$dev"
    return 0
  fi

  # 3) IPv6 default route (IPv6-only VPS)
  dev="$(ip -6 route show default 2>/dev/null | awk '{for (i=1;i<=NF;i++) if ($i=="dev") {print $(i+1); exit}}' || true)"
  if [[ -n "${dev:-}" ]]; then
    echo "$dev"
    return 0
  fi

  echo ""
}

arch_suffix() {
  local a
  a="$(uname -m)"
  case "$a" in
    x86_64|amd64) echo "amd64" ;;
    aarch64|arm64) echo "arm64" ;;
    *) die "Unsupported arch: $a" ;;
  esac
}

apt_install() {
  export DEBIAN_FRONTEND=noninteractive
  apt-get update -y
  apt-get install -y --no-install-recommends \
    ca-certificates curl jq iproute2 iptables wireguard-tools
}

install_wgcf() {
  if has_cmd wgcf; then return 0; fi
  local arch url tmp
  arch="$(arch_suffix)"
  url="https://github.com/ViRb3/wgcf/releases/download/v${WGCF_VERSION}/wgcf_${WGCF_VERSION}_linux_${arch}"
  tmp="$(mktemp)"
  curl -fsSL "$url" -o "$tmp"
  install -m 0755 "$tmp" /usr/local/bin/wgcf
  rm -f "$tmp"
}

install_gost() {
  if has_cmd gost; then return 0; fi
  local arch url tmp
  arch="$(arch_suffix)"
  url="https://github.com/ginuerzh/gost/releases/download/v${GOST_VERSION}/gost-linux-${arch}-${GOST_VERSION}.gz"
  tmp="$(mktemp)"
  curl -fsSL "$url" -o "$tmp"
  gunzip -c "$tmp" >/usr/local/bin/gost
  chmod +x /usr/local/bin/gost
  rm -f "$tmp"
}

ensure_sysctl() {
  cat >"$SYSCTL_FILE" <<'EOFSYS'
net.ipv4.ip_forward=1
EOFSYS
  sysctl --system >/dev/null
}

cfg_path() {
  local i="$1"
  echo "${WG_DIR}/${WG_PREFIX}${i}.conf"
}

state_path() {
  local i="$1"
  echo "${STATE_DIR}/${WG_PREFIX}${i}"
}

ns_name() {
  local i="$1"
  echo "${NS_PREFIX}${i}"
}

subnet_cidr() {
  local i="$1"
  echo "${BASE_NET}.${i}.0/24"
}

host_ip() {
  local i="$1"
  echo "${BASE_NET}.${i}.1"
}

ns_ip() {
  local i="$1"
  echo "${BASE_NET}.${i}.2"
}

veth_host() {
  local i="$1"
  echo "vethw${i}"
}

veth_ns() {
  local i="$1"
  echo "vethn${i}"
}

socks_port() {
  local i="$1"
  echo $((BASE_PORT + i))
}

netns_exists() {
  local ns="$1"
  [[ -e "/run/netns/${ns}" || -e "/var/run/netns/${ns}" ]]
}

ipt() {
  iptables -w 5 "$@"
}

gen_warp_conf() {
  local i="$1"
  local dir conf
  dir="$(state_path "$i")"
  conf="$(cfg_path "$i")"

  mkdir -p "$dir" "$WG_DIR"

  if [[ -f "$conf" ]]; then
    return 0
  fi

  log "Generating WARP config #$i ..."
  (
    set -euo pipefail
    cd "$dir"
    umask 077
    rm -f wgcf-account.toml wgcf-profile.conf

    attempt=1
    while true; do
      out="$(wgcf register --accept-tos 2>&1)" && break

      if echo "$out" | grep -qE '429 Too Many Requests|401 Unauthorized|403 Forbidden'; then
        if [[ "$attempt" -ge "$REGISTER_RETRIES" ]]; then
          echo "$out" >&2
          exit 42
        fi

        sleep_s=$(( REGISTER_BACKOFF_BASE * (2 ** (attempt - 1)) ))
        if [[ "$sleep_s" -gt "$REGISTER_BACKOFF_MAX" ]]; then sleep_s="$REGISTER_BACKOFF_MAX"; fi

        echo "Cloudflare rejected registration (429/401/403) while registering warp${i}. Waiting ${sleep_s}s then retrying..." >&2
        sleep "$sleep_s"
        attempt=$((attempt + 1))
        continue
      fi

      echo "$out" >&2
      exit 43
    done

    out="$(wgcf generate 2>&1)" || { echo "$out" >&2; exit 44; }
    cp wgcf-profile.conf "$conf"
  )
  rc=$?
  if [[ "$rc" -ne 0 ]]; then
    if [[ "$rc" -eq 42 ]]; then
      die "Cloudflare rejected registration (429/401/403) while creating WARP #$i. Wait 15-60 minutes and re-run: warp-multi install (it will resume), or increase --register-delay / --register-retries / --register-backoff-base."
    fi
    die "Failed to generate WARP config #$i (exit $rc)."
  fi

  # Avoid letting wg-quick manage DNS in host; we'll set netns resolv.conf instead.
  sed -i '/^DNS =/d' "$conf" || true

  # Keepalive helps on some VPS providers.
  if ! grep -q '^PersistentKeepalive' "$conf"; then
    sed -i '/^\[Peer\]/a PersistentKeepalive = 25' "$conf"
  fi

  chmod 600 "$conf"
}

write_systemd_units() {
  cat >"$UNIT_NETNS" <<'EOFUNIT1'
[Unit]
Description=WARP netns %i
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/local/bin/warp-multi ns-up %i
ExecStop=/usr/local/bin/warp-multi ns-down %i

[Install]
WantedBy=multi-user.target
EOFUNIT1

  cat >"$UNIT_SOCKS" <<'EOFUNIT2'
[Unit]
Description=WARP SOCKS5 in netns %i
After=warp-netns@%i.service
Requires=warp-netns@%i.service

[Service]
Type=simple
ExecStart=/usr/local/bin/warp-multi socks %i
Restart=on-failure
RestartSec=2

[Install]
WantedBy=multi-user.target
EOFUNIT2

  systemctl daemon-reload
}

cmd_install() {
  require_root

  # start from defaults
  COUNT="$COUNT_DEFAULT"
  BASE_PORT="$BASE_PORT_DEFAULT"
  BASE_NET="$BASE_NET_DEFAULT"
  NS_PREFIX="$NS_PREFIX_DEFAULT"
  WG_PREFIX="$WG_PREFIX_DEFAULT"
  WGCF_VERSION="$WGCF_VERSION_DEFAULT"
  GOST_VERSION="$GOST_VERSION_DEFAULT"
  REGISTER_DELAY="$REGISTER_DELAY_DEFAULT"
  REGISTER_RETRIES="$REGISTER_RETRIES_DEFAULT"
  REGISTER_BACKOFF_BASE="$REGISTER_BACKOFF_BASE_DEFAULT"
  REGISTER_BACKOFF_MAX="$REGISTER_BACKOFF_MAX_DEFAULT"
  UPLINK_IF=""

  local old_count=""
  if [[ -f "$CONFIG_FILE" ]]; then
    load_config
    old_count="${COUNT:-}"
  fi

  # parse flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --count) COUNT="${2:?}"; shift 2 ;;
      --base-port) BASE_PORT="${2:?}"; shift 2 ;;
      --base-net) BASE_NET="${2:?}"; shift 2 ;;
      --ns-prefix) NS_PREFIX="${2:?}"; shift 2 ;;
      --wg-prefix) WG_PREFIX="${2:?}"; shift 2 ;;
      --uplink-if) UPLINK_IF="${2:?}"; shift 2 ;;
      --wgcf-version) WGCF_VERSION="${2:?}"; shift 2 ;;
      --gost-version) GOST_VERSION="${2:?}"; shift 2 ;;
      --register-delay) REGISTER_DELAY="${2:?}"; shift 2 ;;
      --register-retries) REGISTER_RETRIES="${2:?}"; shift 2 ;;
      --register-backoff-base) REGISTER_BACKOFF_BASE="${2:?}"; shift 2 ;;
      --register-backoff-max) REGISTER_BACKOFF_MAX="${2:?}"; shift 2 ;;
      -h|--help) usage_install; exit 0 ;;
      *) die "Unknown flag: $1" ;;
    esac
  done

  [[ "$COUNT" =~ ^[0-9]+$ ]] || die "--count must be a number"
  [[ "$COUNT" -ge 1 ]] || die "--count must be >= 1"
  [[ "$COUNT" -le 200 ]] || warn "High --count ($COUNT). Consider <= 200 to keep routing manageable."

  [[ "$BASE_PORT" =~ ^[0-9]+$ ]] || die "--base-port must be a number"
  [[ "$BASE_PORT" -ge 1024 ]] || warn "--base-port < 1024 needs extra care; continuing anyway."

  [[ "$REGISTER_DELAY" =~ ^[0-9]+$ ]] || die "--register-delay must be a number (seconds)"
  [[ "$REGISTER_RETRIES" =~ ^[0-9]+$ ]] || die "--register-retries must be a number"
  [[ "$REGISTER_RETRIES" -ge 1 ]] || die "--register-retries must be >= 1"
  [[ "$REGISTER_BACKOFF_BASE" =~ ^[0-9]+$ ]] || die "--register-backoff-base must be a number (seconds)"
  [[ "$REGISTER_BACKOFF_BASE" -ge 1 ]] || die "--register-backoff-base must be >= 1"
  [[ "$REGISTER_BACKOFF_MAX" =~ ^[0-9]+$ ]] || die "--register-backoff-max must be a number (seconds)"
  [[ "$REGISTER_BACKOFF_MAX" -ge 1 ]] || die "--register-backoff-max must be >= 1"

  if [[ -z "${UPLINK_IF:-}" ]]; then
    UPLINK_IF="$(detect_uplink)"
  fi
  [[ -n "${UPLINK_IF:-}" ]] || die "Could not detect uplink interface; set with --uplink-if <iface> (hint: ip -4 route show default)"
  ip link show "$UPLINK_IF" >/dev/null 2>&1 || die "Uplink interface '$UPLINK_IF' not found. Pick the interface from: ip -4 route show default"

  if ! has_cmd apt-get; then
    die "Installer supports Ubuntu/Debian (apt) only."
  fi

  apt_install
  install_wgcf
  install_gost
  ensure_sysctl

  save_config

  write_systemd_units

  mkdir -p "$STATE_DIR" "$WG_DIR"
  local i conf
  for i in $(seq 1 "$COUNT"); do
    conf="$(cfg_path "$i")"
    if [[ ! -f "$conf" ]]; then
      gen_warp_conf "$i"
      if [[ "$REGISTER_DELAY" -gt 0 ]] && [[ "$i" -lt "$COUNT" ]]; then
        sleep "$REGISTER_DELAY"
      fi
    fi
    systemctl enable --now "warp-netns@${i}.service" "warp-socks@${i}.service"
  done

  # If count got smaller, stop/disable the old extra services
  if [[ -n "${old_count:-}" ]] && [[ "${old_count}" =~ ^[0-9]+$ ]] && [[ "$old_count" -gt "$COUNT" ]]; then
    for i in $(seq $((COUNT + 1)) "$old_count"); do
      systemctl disable --now "warp-socks@${i}.service" "warp-netns@${i}.service" 2>/dev/null || true
    done
  fi

  log "Installed. SOCKS5 endpoints:"
  cmd_proxies
}

cmd_ns_up() {
  require_root
  load_config

  local i="${1:?}"
  local ns conf sub hostip nsip vh vn
  ns="$(ns_name "$i")"
  conf="$(cfg_path "$i")"
  sub="$(subnet_cidr "$i")"
  hostip="$(host_ip "$i")"
  nsip="$(ns_ip "$i")"
  vh="$(veth_host "$i")"
  vn="$(veth_ns "$i")"

  [[ -f "$conf" ]] || die "Missing config: $conf (run: warp-multi install)"

  ip netns del "$ns" 2>/dev/null || true
  ip link del "$vh" 2>/dev/null || true

  ip netns add "$ns"
  ip link add "$vh" type veth peer name "$vn"
  ip link set "$vn" netns "$ns"

  ip addr add "${hostip}/24" dev "$vh"
  ip link set "$vh" up

  ip netns exec "$ns" ip addr add "${nsip}/24" dev "$vn"
  ip netns exec "$ns" ip link set "$vn" up
  ip netns exec "$ns" ip link set lo up
  ip netns exec "$ns" ip route add default via "$hostip"

  mkdir -p "/etc/netns/$ns"
  cat >"/etc/netns/$ns/resolv.conf" <<EOFRES
nameserver 1.1.1.1
nameserver 1.0.0.1
EOFRES

  ipt -t nat -C POSTROUTING -s "$sub" -o "$UPLINK_IF" -j MASQUERADE 2>/dev/null || \
    ipt -t nat -A POSTROUTING -s "$sub" -o "$UPLINK_IF" -j MASQUERADE

  ipt -C FORWARD -i "$vh" -o "$UPLINK_IF" -j ACCEPT 2>/dev/null || \
    ipt -A FORWARD -i "$vh" -o "$UPLINK_IF" -j ACCEPT

  ipt -C FORWARD -i "$UPLINK_IF" -o "$vh" -m state --state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null || \
    ipt -A FORWARD -i "$UPLINK_IF" -o "$vh" -m state --state RELATED,ESTABLISHED -j ACCEPT

  ip netns exec "$ns" wg-quick up "$conf" >/dev/null
}

cmd_ns_down() {
  require_root
  load_config

  local i="${1:?}"
  local ns conf sub vh
  ns="$(ns_name "$i")"
  conf="$(cfg_path "$i")"
  sub="$(subnet_cidr "$i")"
  vh="$(veth_host "$i")"

  ip netns exec "$ns" wg-quick down "$conf" >/dev/null 2>&1 || true

  ipt -t nat -D POSTROUTING -s "$sub" -o "$UPLINK_IF" -j MASQUERADE 2>/dev/null || true
  ipt -D FORWARD -i "$vh" -o "$UPLINK_IF" -j ACCEPT 2>/dev/null || true
  ipt -D FORWARD -i "$UPLINK_IF" -o "$vh" -m state --state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null || true

  ip link del "$vh" 2>/dev/null || true
  ip netns del "$ns" 2>/dev/null || true
}

cmd_socks() {
  require_root
  load_config

  local i="${1:?}"
  local ns nsip port
  ns="$(ns_name "$i")"
  nsip="$(ns_ip "$i")"
  port="$(socks_port "$i")"

  exec ip netns exec "$ns" /usr/local/bin/gost -L "socks5://${nsip}:${port}"
}

cmd_proxies() {
  load_config
  local i
  for i in $(seq 1 "$COUNT"); do
    printf "warp%02d -> %s:%s\n" "$i" "$(ns_ip "$i")" "$(socks_port "$i")"
  done
}

get_exit_ip() {
  local ns="$1"
  if ! netns_exists "$ns"; then
    return 20
  fi
  ip netns exec "$ns" curl -fsS --max-time 10 https://cloudflare.com/cdn-cgi/trace 2>/dev/null \
    | awk -F= '/^ip=/{print $2; exit}'
}

cmd_ip() {
  load_config
  local i="${1:?}"
  local ns
  ns="$(ns_name "$i")"
  local ip rc
  if ip="$(get_exit_ip "$ns")"; then
    echo "$ip"
    return 0
  fi
  rc=$?
  if [[ "$rc" -eq 20 ]]; then
    echo "MISSING_NETNS"
  else
    echo "N/A"
  fi
}

cmd_ips() {
  load_config
  local i ns ip
  for i in $(seq 1 "$COUNT"); do
    ns="$(ns_name "$i")"
    printf "warp%02d: " "$i"
    if ip="$(get_exit_ip "$ns")"; then
      echo "$ip"
    else
      if [[ "$?" -eq 20 ]]; then
        echo "MISSING_NETNS"
      else
        echo "N/A"
      fi
    fi
  done
}

cmd_up() {
  require_root
  load_config

  if [[ ! -f "$UNIT_NETNS" || ! -f "$UNIT_SOCKS" ]]; then
    write_systemd_units
  fi

  local i
  for i in $(seq 1 "$COUNT"); do
    systemctl enable --now "warp-netns@${i}.service" "warp-socks@${i}.service"
  done
}

cmd_down() {
  require_root
  load_config

  local i
  for i in $(seq 1 "$COUNT"); do
    systemctl stop "warp-socks@${i}.service" "warp-netns@${i}.service" 2>/dev/null || true
  done
}

cmd_restart() {
  require_root
  load_config

  local which="${1:-all}"
  if [[ "$which" == "all" ]]; then
    local i
    for i in $(seq 1 "$COUNT"); do
      systemctl restart "warp-netns@${i}.service" "warp-socks@${i}.service"
    done
    return 0
  fi

  [[ "$which" =~ ^[0-9]+$ ]] || die "Usage: warp-multi restart <index|all>"
  systemctl restart "warp-netns@${which}.service" "warp-socks@${which}.service"
}

cmd_rotate() {
  require_root
  load_config

  local i="${1:?}"
  [[ "$i" =~ ^[0-9]+$ ]] || die "Usage: warp-multi rotate <index>"

  systemctl stop "warp-socks@${i}.service" "warp-netns@${i}.service" 2>/dev/null || true

  rm -f "$(cfg_path "$i")" || true
  rm -rf "$(state_path "$i")" || true

  gen_warp_conf "$i"

  systemctl start "warp-netns@${i}.service" "warp-socks@${i}.service"

  log "New exit IP for warp$(printf '%02d' "$i"): $(cmd_ip "$i")"
}

cmd_rotate_all() {
  require_root
  load_config

  local i
  for i in $(seq 1 "$COUNT"); do
    cmd_rotate "$i"
  done
}

cmd_status() {
  require_root
  load_config

  local i active ip addr port
  for i in $(seq 1 "$COUNT"); do
    active="$(systemctl is-active "warp-socks@${i}.service" 2>/dev/null || true)"
    addr="$(ns_ip "$i")"
    port="$(socks_port "$i")"
    ip="$(cmd_ip "$i" 2>/dev/null || true)"
    printf "warp%02d  socks=%s:%s  service=%s  exit_ip=%s\n" "$i" "$addr" "$port" "${active:-unknown}" "${ip:-N/A}"
  done
}

cmd_uninstall() {
  require_root
  load_config || true

  local count="${COUNT:-$COUNT_DEFAULT}"
  local i

  for i in $(seq 1 "$count"); do
    systemctl disable --now "warp-socks@${i}.service" "warp-netns@${i}.service" 2>/dev/null || true
    # best-effort cleanup
    cmd_ns_down "$i" 2>/dev/null || true
    rm -f "$(cfg_path "$i")" 2>/dev/null || true
    rm -rf "$(state_path "$i")" 2>/dev/null || true
  done

  rm -f "$UNIT_NETNS" "$UNIT_SOCKS" 2>/dev/null || true
  systemctl daemon-reload 2>/dev/null || true

  rm -f "$CONFIG_FILE" 2>/dev/null || true
  rm -rf "$STATE_DIR" 2>/dev/null || true
  rm -f "$SYSCTL_FILE" 2>/dev/null || true
  sysctl --system >/dev/null 2>&1 || true

  log "Uninstalled."
}

usage_install() {
  cat <<EOFU
warp-multi install [options]

Options:
  --count N          Number of WARP outbounds (default: ${COUNT_DEFAULT})
  --base-port P      Base port for SOCKS5 (default: ${BASE_PORT_DEFAULT}; ports are P+1..P+N)
  --base-net A.B     Base /16 for veth subnets (default: ${BASE_NET_DEFAULT})
  --uplink-if IFACE  Uplink interface name (auto-detected if not set)
  --ns-prefix STR    Namespace prefix (default: ${NS_PREFIX_DEFAULT})
  --wg-prefix STR    WireGuard config prefix (default: ${WG_PREFIX_DEFAULT})
  --wgcf-version V   wgcf version (default: ${WGCF_VERSION_DEFAULT})
  --gost-version V   gost version (default: ${GOST_VERSION_DEFAULT})
  --register-delay S         Seconds to wait between registrations (default: ${REGISTER_DELAY_DEFAULT})
  --register-retries N       Retries when Cloudflare returns 429 (default: ${REGISTER_RETRIES_DEFAULT})
  --register-backoff-base S  Exponential backoff base seconds (default: ${REGISTER_BACKOFF_BASE_DEFAULT})
  --register-backoff-max S   Max backoff seconds (default: ${REGISTER_BACKOFF_MAX_DEFAULT})

Examples:
  warp-multi install
  warp-multi install --count 10 --base-port 40000 --base-net 10.250
  warp-multi install --uplink-if ens3
  warp-multi install --count 10 --register-delay 12
EOFU
}

usage() {
  cat <<EOFU
warp-multi v${VERSION}

Commands:
  install [flags]          Install deps, generate configs, enable services
  up                       Start/enable all services (does not re-register)
  down                     Stop all services (keeps configs)
  proxies                  Print SOCKS5 endpoints (for x-ui/xray outbounds)
  ip <i>                   Show exit IP for one tunnel
  ips                      Show exit IPs for all tunnels
  status                   Show service status + exit IPs
  restart <i|all>          Restart one or all tunnels
  rotate <i>               Regenerate wgcf account/config for one tunnel (changes keys; usually changes exit IP)
  rotate-all               Rotate all tunnels
  ns-up <i>                (internal) bring up netns + wg
  ns-down <i>              (internal) bring down netns + wg
  socks <i>                (internal) run SOCKS5 proxy inside netns
  uninstall                Stop services and remove installed files

Config file:
  ${CONFIG_FILE}

Tip (to change exit location/IP sometimes):
  Edit Endpoint in /etc/wireguard/${WG_PREFIX}<i>.conf then:
    warp-multi restart <i>
EOFU
}

main() {
  # Ensure defaults are set even when user runs `warp-multi --help` (no config loaded).
  ensure_defaults

  local cmd="${1:-}"
  shift || true
  case "$cmd" in
    install) cmd_install "$@" ;;
    up) cmd_up "$@" ;;
    down) cmd_down "$@" ;;
    proxies) cmd_proxies "$@" ;;
    ip) cmd_ip "$@" ;;
    ips) cmd_ips "$@" ;;
    status) cmd_status "$@" ;;
    restart) cmd_restart "$@" ;;
    rotate) cmd_rotate "$@" ;;
    rotate-all) cmd_rotate_all "$@" ;;
    ns-up) cmd_ns_up "$@" ;;
    ns-down) cmd_ns_down "$@" ;;
    socks) cmd_socks "$@" ;;
    uninstall) cmd_uninstall "$@" ;;
    -h|--help|"") usage; exit 0 ;;
    *) die "Unknown command: $cmd (use: warp-multi --help)" ;;
  esac
}

main "$@"

